<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>EasyExcel学习</title>
    <url>/2023/02/27/EasyExcel%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Easyexcel"><a href="#Easyexcel" class="headerlink" title="Easyexcel"></a>Easyexcel</h2><p>EasyExcel是一个基于Java的简单、省内存的读写Excel的开源项目。在尽可能节约内存的情况下支持读写百M的Excel</p>
<p>项目github地址：<a href="https://github.com/alibaba/easyexcel">https://github.com/alibaba/easyexcel</a> </p>
<p>官网地址：<a href="https://easyexcel.opensource.alibaba.com/docs/current/">https://easyexcel.opensource.alibaba.com/docs/current/</a></p>
<p>先吐槽一下，官方文档写的太烂了，缺少依赖、逻辑不清晰、复制到idea很多跑起来报错</p>
<h4 id="写Excel"><a href="#写Excel" class="headerlink" title="写Excel"></a>写Excel</h4><ul>
<li>准备工作</li>
</ul>
<p>创建项目，在pom文件中添加以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- easyexcel 依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建一个实体类，用于写入excel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &#123;&quot;学生编号&quot;&#125;,order = 10)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &#123;&quot;学生姓名&quot;&#125;,order = 2)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &#123;&quot;学生薪水&quot;&#125;,order = 1)</span></span><br><span class="line">    <span class="keyword">private</span> Double salary;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &#123;&quot;学生生日&quot;&#125;,order = 11)</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最简单的写入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成数据</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Student&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.setId(i + <span class="number">1</span>);</span><br><span class="line">        student.setName(<span class="string">&quot;李四&quot;</span> + i);</span><br><span class="line">        student.setBirthday(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        student.setSalary(<span class="number">1500.00D</span>);</span><br><span class="line">        lists.add(student);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最简单的写入</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    EasyExcel.write(<span class="string">&quot;学生信息表.xlsx&quot;</span>, Student.class).sheet().doWrite(getData());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>PS:一下方法都是有关最简单写入的具体方法解释，不感兴趣的可以跳过</em></p>
<h5 id="write方法"><a href="#write方法" class="headerlink" title="write方法"></a>write方法</h5><p>代码解释：</p>
<p><code>EasyExcel.write</code>源码如下：两个重载的方法，接收文件名（含路径）或文件名和Excel头文件</p>
<p>，new 了一个ExcelWriterBuilder对象，将pathName或head写入excelWriterBuilder并返回</p>
<ul>
<li>pathName:文件名</li>
<li>head:写入表格的class对象，如上方Student.class对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyExcelFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个Excel写对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExcelWriterBuilder <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExcelWriterBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个Excel写对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file 用来写出文件对象</span></span><br><span class="line"><span class="comment">     *            </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Excel writer builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExcelWriterBuilder <span class="title function_">write</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> write(file, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建 Excel写对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     *           用来写出的文件对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     *          写出的数据类型的class对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Excel writer builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExcelWriterBuilder <span class="title function_">write</span><span class="params">(File file, Class head)</span> &#123;</span><br><span class="line">        <span class="type">ExcelWriterBuilder</span> <span class="variable">excelWriterBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExcelWriterBuilder</span>();</span><br><span class="line">        excelWriterBuilder.file(file);</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            excelWriterBuilder.head(head);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> excelWriterBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建Excel 写对象</span></span><br><span class="line"><span class="comment">     *   </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pathName</span></span><br><span class="line"><span class="comment">     *           写出的文件路径名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Excel writer builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExcelWriterBuilder <span class="title function_">write</span><span class="params">(String pathName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> write(pathName, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建excel 写对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pathName</span></span><br><span class="line"><span class="comment">     *            写出的文件路径名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     *            写出数据的数据类型的class对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Excel writer builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExcelWriterBuilder <span class="title function_">write</span><span class="params">(String pathName, Class head)</span> &#123;</span><br><span class="line">        <span class="type">ExcelWriterBuilder</span> <span class="variable">excelWriterBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExcelWriterBuilder</span>();</span><br><span class="line">        excelWriterBuilder.file(pathName);</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            excelWriterBuilder.head(head);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> excelWriterBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建excel写对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     *            写出的输出流对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Excel writer builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExcelWriterBuilder <span class="title function_">write</span><span class="params">(OutputStream outputStream)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> write(outputStream, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建excel写对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     *           写出的输出流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     *           写出数据的数据类型的class对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Excel writer builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExcelWriterBuilder <span class="title function_">write</span><span class="params">(OutputStream outputStream, Class head)</span> &#123;</span><br><span class="line">        <span class="type">ExcelWriterBuilder</span> <span class="variable">excelWriterBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExcelWriterBuilder</span>();</span><br><span class="line">        excelWriterBuilder.file(outputStream);</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            excelWriterBuilder.head(head);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> excelWriterBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sheet-方法"><a href="#sheet-方法" class="headerlink" title="sheet()方法"></a>sheet()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    EasyExcel</span><br><span class="line">        .write(<span class="string">&quot;学生信息表.xlsx&quot;</span>, Student.class)</span><br><span class="line">        .sheet()</span><br><span class="line">        .doWrite(getData());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sheet()方法代表要在excel那个sheet页写入数据，如果不指定，，默认写在第一个sheet页，默认sheet名：0</p>
<p>源码解释：所有重载的方法可归为一个方法，接收sheetNo(第几个sheet（Integer）)，sheetName(sheet页名称(String))，返回ExcelWriterSheetBuilder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      选中第一个sheet页</span></span><br><span class="line"><span class="comment">      写操作 sheet 页的值为 0</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> ExcelWriterSheetBuilder <span class="title function_">sheet</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> sheet(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      选中 第一个的 sheet页</span></span><br><span class="line"><span class="comment">      sheet 页的名字 为 sheetNo</span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line">  <span class="keyword">public</span> ExcelWriterSheetBuilder <span class="title function_">sheet</span><span class="params">(Integer sheetNo)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> sheet(sheetNo, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      选中第一个的 sheet页</span></span><br><span class="line"><span class="comment">      sheet 页的名字 为 sheetName</span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line">  <span class="keyword">public</span> ExcelWriterSheetBuilder <span class="title function_">sheet</span><span class="params">(String sheetName)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> sheet(<span class="literal">null</span>, sheetName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      选中第一个 sheet页</span></span><br><span class="line"><span class="comment">      sheet 页的名字 为 sheetNo 或者 sheetName</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> ExcelWriterSheetBuilder <span class="title function_">sheet</span><span class="params">(Integer sheetNo, String sheetName)</span> &#123;</span><br><span class="line">      <span class="type">ExcelWriter</span> <span class="variable">excelWriter</span> <span class="operator">=</span> build();</span><br><span class="line">      <span class="type">ExcelWriterSheetBuilder</span> <span class="variable">excelWriterSheetBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExcelWriterSheetBuilder</span>(excelWriter);</span><br><span class="line">      <span class="keyword">if</span> (sheetNo != <span class="literal">null</span>) &#123;</span><br><span class="line">          excelWriterSheetBuilder.sheetNo(sheetNo);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sheetName != <span class="literal">null</span>) &#123;</span><br><span class="line">          excelWriterSheetBuilder.sheetName(sheetName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> excelWriterSheetBuilder;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h5 id="doWrite方法"><a href="#doWrite方法" class="headerlink" title="doWrite方法"></a>doWrite方法</h5><p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWrite</span><span class="params">(List data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.excelWriter == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExcelGenerateException</span>(<span class="string">&quot;Must use &#x27;EasyExcelFactory.write().sheet()&#x27; to call this method&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.excelWriter.write(data, <span class="built_in">this</span>.build());</span><br><span class="line">            <span class="built_in">this</span>.excelWriter.finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如上可见，doWrite方法只是简单判断了一下当前ExcelWriterSheetBuilder类是否为空，然后调用了write方法，再关闭excelWriter</p>
<p>我们在深入看一下write方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ExcelWriter <span class="title function_">write</span><span class="params">(List data, WriteSheet writeSheet)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.write(data, (WriteSheet)writeSheet, (WriteTable)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ExcelWriter <span class="title function_">write</span><span class="params">(List data, WriteSheet writeSheet, WriteTable writeTable)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.excelBuilder.addContent(data, writeSheet, writeTable);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质上这两个方法属于一个方法，都是接收三个参数，返回ExcelWriter对象</p>
<ul>
<li>List data: 要写入的数据</li>
<li>WriteSheet writeSheet: doWrite方法返回ExcelWriterSheetBuilder中的一个属性，存放了sheet信息</li>
<li>writeTable:  存放table信息，暂不讨论</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> ExcelWriter <span class="title function_">write</span><span class="params">(List data, Sheet sheet)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.write(data, (Sheet)sheet, (Table)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> ExcelWriter <span class="title function_">write</span><span class="params">(List data, Sheet sheet, Table table)</span> &#123;</span><br><span class="line">    <span class="type">WriteSheet</span> <span class="variable">writeSheet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (sheet != <span class="literal">null</span>) &#123;</span><br><span class="line">        writeSheet = <span class="keyword">new</span> <span class="title class_">WriteSheet</span>();</span><br><span class="line">        writeSheet.setSheetNo(sheet.getSheetNo() - <span class="number">1</span>);</span><br><span class="line">        writeSheet.setSheetName(sheet.getSheetName());</span><br><span class="line">        writeSheet.setClazz(sheet.getClazz());</span><br><span class="line">        writeSheet.setHead(sheet.getHead());</span><br><span class="line">        writeSheet.setTableStyle(sheet.getTableStyle());</span><br><span class="line">        writeSheet.setRelativeHeadRowIndex(sheet.getStartRow());</span><br><span class="line">        writeSheet.setColumnWidthMap(sheet.getColumnWidthMap());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.write(data, writeSheet, writeTable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已过时方法，本质如上,根据return语句看，还是调用以上方法，</p>
<h5 id="接着看一下addContent"><a href="#接着看一下addContent" class="headerlink" title="接着看一下addContent"></a>接着看一下addContent</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addContent</span><span class="params">(List data, WriteSheet writeSheet)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.addContent(data, writeSheet, (WriteTable)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addContent</span><span class="params">(List data, WriteSheet writeSheet, WriteTable writeTable)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context.currentSheet(writeSheet, WriteTypeEnum.ADD);</span><br><span class="line">        <span class="built_in">this</span>.context.currentTable(writeTable);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.excelWriteAddExecutor == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.excelWriteAddExecutor = <span class="keyword">new</span> <span class="title class_">ExcelWriteAddExecutor</span>(<span class="built_in">this</span>.context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.excelWriteAddExecutor.add(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException var5) &#123;</span><br><span class="line">        <span class="built_in">this</span>.finishOnException();</span><br><span class="line">        <span class="keyword">throw</span> var5;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">        <span class="built_in">this</span>.finishOnException();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExcelGenerateException</span>(var6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addContent接收了Excel原始数据，通过excelWriteAddExecutor.add写入，具体写入过程可看此方法</p>
<h4 id="表头操作"><a href="#表头操作" class="headerlink" title="表头操作"></a>表头操作</h4><h5 id="属性注解"><a href="#属性注解" class="headerlink" title="属性注解"></a>属性注解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &#123;&quot;学生编号&quot;&#125;,order = 10)</span></span><br><span class="line">    <span class="meta">@NumberFormat(&quot;#,###&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &#123;&quot;学生姓名&quot;&#125;,order = 2)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &#123;&quot;学生薪水&quot;&#125;,order = 1)</span></span><br><span class="line">    <span class="meta">@ExcelIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Double salary;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &#123;&quot;学生生日&quot;&#125;,order = 11)</span></span><br><span class="line">    <span class="meta">@DateTimeFormat(&quot;yyyy-mm-dd&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所见，我们在每个属性上加入了@ExcelProperty注解，表示当前属性是一个excel字段，easyexcel采用了注解的方式定义excel 表头字段，给我们开发带来了极大的便利。</p>
<ul>
<li><code>ExcelProperty</code> index 指定写到第几列，默认根据成员变量排序。<code>value</code>指定写入的名称，默认成员变量的名字，多个<code>value</code>可以参照快速开始中的复杂头</li>
<li><code>ExcelIgnore</code> 默认所有字段都会写入excel，这个注解会忽略这个字段</li>
<li><code>DateTimeFormat</code> 日期转换，将<code>Date</code>写到excel会调用这个注解。里面的<code>value</code>参照<code>java.text.SimpleDateFormat</code></li>
<li><code>NumberFormat</code> 数字转换，用<code>Number</code>写excel会调用这个注解。里面的<code>value</code>参照<code>java.text.DecimalFormat</code></li>
<li><code>ExcelIgnoreUnannotated</code> 默认不加<code>ExcelProperty</code> 的注解的都会参与读写，加了不会参与</li>
</ul>
<p>还有其他注解，地址都在：com.alibaba.excel.annotation</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 Steam API</title>
    <url>/2023/02/03/Java8-Steam-API/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java8-Steam-API"><a href="#Java8-Steam-API" class="headerlink" title="Java8 Steam API"></a>Java8 Steam API</h1><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><ul>
<li><code>Stream API ( java.util.stream)</code> 把真正的函数式编程风格引入到<code>Java</code>中。这 是目前为止对<code>Java</code>类库最好的补充，因为<code>Stream API</code>可以极大提供Java程 序员的生产力，让程序员写出高效率、干净、简洁的代码。</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>实际开发中，项目中多数数据源都来自于<code>Mysql</code>，<code>Oracle</code>等。但现在数 据源可以更多了，有<code>MongDB</code>，<code>Radis</code>等，而这些<strong>NoSQL</strong>的数据就需要 <code>Java</code>层面去处理</li>
<li><code>Stream</code> 和 <code>Collection</code> 集合的区别：<code>Collection</code> 是一种静态的内存数据 结构，而 <code>Stream</code> 是有关计算的。前者是主要面向内存，存储在内存中， 后者主要是面向 CPU，通过 CPU 实现计算。</li>
</ul>
<h5 id="Stream-操作的三个步骤"><a href="#Stream-操作的三个步骤" class="headerlink" title="Stream 操作的三个步骤"></a>Stream 操作的三个步骤</h5><ul>
<li><p>创建Stream，获取一个工作流</p>
<ul>
<li>​	数据源（集合、数组。。。）</li>
</ul>
</li>
<li><p>中间操作，对数据进行中间处理</p>
</li>
<li><p>终止操作</p>
</li>
</ul>
<h4 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h4><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个顺序流</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个并行流</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个流</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">stream</span><span class="params">(T[] array)</span> </span><br></pre></td></tr></table></figure>

<h5 id="stream-of"><a href="#stream-of" class="headerlink" title="stream of"></a>stream of</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T... values)</span></span><br></pre></td></tr></table></figure>

<h5 id="无限流"><a href="#无限流" class="headerlink" title="无限流"></a>无限流</h5><h6 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span></span><br></pre></td></tr></table></figure>

<h6 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">generate</span><span class="params">(Supplier&lt;T&gt; s)</span></span><br></pre></td></tr></table></figure>

<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 迭代</span></span><br><span class="line">    <span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final</span></span><br><span class="line">    <span class="comment">// UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">0</span>, x -&gt; x + <span class="number">2</span>);</span><br><span class="line">    stream.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成</span></span><br><span class="line">    <span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">    Stream&lt;Double&gt; stream1 = Stream.generate(Math::random);</span><br><span class="line">    stream1.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><h5 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h5><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>filter(Predicate p)</td>
<td>接受Lambda,从流中排除某些元素</td>
</tr>
<tr>
<td>distinct()</td>
<td>筛选，通过流所生成元素的hashCode()和equals() 去除重复元素</td>
</tr>
<tr>
<td>limit（long maxSize)</td>
<td>截断流，使其元素不超过给定数量</td>
</tr>
<tr>
<td>skip(long n)</td>
<td>跳过元素，返回一个扔掉了前n个元素的流，不足n放回空流</td>
</tr>
</tbody></table>
<h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>map(Function f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，<br>并将其映射成一个新的元素。</td>
</tr>
<tr>
<td>mapToDouble(ToDoubleFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream</td>
</tr>
<tr>
<td>mapToInt(ToIntFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到灭个元素上，产生一个新的IntStream</td>
</tr>
<tr>
<td>mapToLong(ToLongFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream</td>
</tr>
<tr>
<td>flatMap(Function f)</td>
<td>接收一个函数作为参数，将流中毒的每个值都换成一个流，然后把所有的流连接成一个流</td>
</tr>
</tbody></table>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>sorted()</td>
<td>产生一个新流，其中按自然顺序排序</td>
</tr>
<tr>
<td>sorted(Comparator com)</td>
<td>产生一个新流，其中按比较器顺序排序</td>
</tr>
</tbody></table>
<h3 id="Stream终止操作"><a href="#Stream终止操作" class="headerlink" title="Stream终止操作"></a>Stream终止操作</h3><h4 id="匹配与查找"><a href="#匹配与查找" class="headerlink" title="匹配与查找"></a>匹配与查找</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>allMatch(Predicate p)</td>
<td>检查是否匹配所有元素</td>
</tr>
<tr>
<td>anyMatch(Predicate p)</td>
<td>检查是否至少匹配一个元素</td>
</tr>
<tr>
<td>noneMatch(Predicate p)</td>
<td>检查是否没有匹配所有元素</td>
</tr>
<tr>
<td>findFirst()</td>
<td>返回第一个元素</td>
</tr>
<tr>
<td>findAny()</td>
<td>返回任一元素</td>
</tr>
<tr>
<td>count()</td>
<td>返回流中元素总数</td>
</tr>
<tr>
<td>max(Comparator c)</td>
<td>返回流中最大值</td>
</tr>
<tr>
<td>min(Comparator c)</td>
<td>返回流中的最小值</td>
</tr>
<tr>
<td>forEach(Consumer c)</td>
<td>内部迭代（使用Conllection接口需要用户去做迭代，称为外部迭代。相反，Stream API使用内部迭代)</td>
</tr>
</tbody></table>
<h4 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>reduce(T iden，BinaryOperator b)</td>
<td>可以将流中元素反复结合起来，的带一个值，返回T</td>
</tr>
<tr>
<td>reduce(BinaryOperator b)</td>
<td>可以将流中元素反复结合起来，的带一个值。返回Opeional<T></td>
</tr>
</tbody></table>
<p><em>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google  用它来进行网络搜索而出名。</em></p>
<h4 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>collect(Collector c)</td>
<td>将流转换为其他形式，接收一个Collector接口的实现，<br>用于给Stream中元素做汇总方法</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建</title>
    <url>/2023/02/03/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Hexo博客搭建"><a href="#Hexo博客搭建" class="headerlink" title="Hexo博客搭建"></a>Hexo博客搭建</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>手里刚买了两个域名，一个用来套<code>cloudflare</code>拯救我的小机场，一个就闲置下来了，偶然想到，如果域名也用<code>cloudflare</code>代理，那使用<code>githubPages</code>搭建博客访问速度也就可以接受了，而且相对国内服务器价格水涨船高+域名备案，想要拥有一个个人网站的小博客也困难重重，所以花了一下午，跟着教程搭建了这个博客</p>
<p><em><strong>准备项：</strong></em></p>
<ul>
<li><em><strong>域名（貌似国内外都可以，我用的国外的（<code>namesilo</code>）</strong></em></li>
<li><em><strong><code>CloudFlare</code>账号</strong></em></li>
<li><em><strong><code>Github</code>账号(如果使用<code>gitee</code>可以跳过第三项)</strong></em></li>
<li><em><strong>本机电脑安装Git、<code>nodeJS</code></strong></em></li>
<li><em><strong>科学上网（本地电脑全局代理）推荐clash</strong></em></li>
</ul>
<h4 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><p><em>参考教程：<a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站</a></em></p>
<p>这里我不做详细步骤阐述，只说一些注意点</p>
<h5 id="（1）创建Github仓库"><a href="#（1）创建Github仓库" class="headerlink" title="（1）创建Github仓库"></a>（1）创建<code>Github</code>仓库</h5><ul>
<li>点击右上角头像 -&gt; your repositories -&gt; 右上方点击 new -&gt; 新建一个仓库</li>
</ul>
<p><em><strong>注意：填写仓库名，格式必须为<code>&lt;用户名&gt;.github.io</code>，然后点击<code>Create repository</code>。</strong></em></p>
<p><em>这也是你的<code>githubpage</code>访问地址</em></p>
<ul>
<li><code>Desciption</code>可简要描述，不填也可</li>
<li>下方选择<code>public</code>  作为公共仓库</li>
<li>Add a README （描述文件，可不选）</li>
<li>Add .gitgnore  (git提交忽略文件设置，可不选)</li>
<li>Choose a license （选择一个许可证， 可不选）</li>
<li>点击Create repository</li>
</ul>
<p>到此为止，新建仓库完成，可以 <code>creating a new file</code>生成一个index.html 测试 &lt;用户名&gt;.github.io 访问是否成功</p>
<h5 id="（2）安装-hexo-静态博客"><a href="#（2）安装-hexo-静态博客" class="headerlink" title="（2）安装 hexo 静态博客"></a>（2）安装 hexo 静态博客</h5><ul>
<li><p>安装 <code>Hexo</code> 并查看是否安装成功： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="comment">//如果 控制台没有滚动安装，检查是否安装nodejs 和 nodejs 的环境遍历</span></span><br><span class="line">hexo -v</span><br><span class="line"><span class="comment">//打印出hexo 版本</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个项目</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化 项目 hexo-blog 为项目名称</span></span><br><span class="line">hexo init hexo-blog</span><br><span class="line"><span class="comment">// 进入 hexo-blog目录</span></span><br><span class="line">cd hexo-blog</span><br><span class="line"><span class="comment">// npm 安装</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地启动</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hexo generate 的缩写  生成网站静态文件到默认设置的 public 文件夹</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment">// hexo server 缩写 本地启动hexo  默认端口4000  http://localhost:4000</span></span><br><span class="line">hexo s</span><br><span class="line"><span class="comment">// 打开浏览器应该能够看到hexo的主页了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主题安装</p>
</li>
</ul>
<p><code>Hexo</code> 默认的主题不太好看，按照教程推荐，我安装了 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a>，推荐使用官方安装教程，我这里简略说一下</p>
<h5 id="一键安装（方法一）：我没有成功"><a href="#一键安装（方法一）：我没有成功" class="headerlink" title="一键安装（方法一）：我没有成功"></a><em>一键安装（方法一）：</em>我没有成功</h5><p>  <code>npm install --save hexo-theme-fluid</code> </p>
<h5 id="手动下载（方法二）："><a href="#手动下载（方法二）：" class="headerlink" title="手动下载（方法二）："></a>手动下载（方法二）：</h5><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a> 解压到 themes 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p>
<h6 id="指定主题"><a href="#指定主题" class="headerlink" title="指定主题"></a>指定主题</h6><p>如下修改 <code>Hexo</code> 博客目录中的 <code>_config.yml</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: fluid  # 指定主题</span><br><span class="line">language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="4-创建「关于页」"><a href="#4-创建「关于页」" class="headerlink" title="4. 创建「关于页」"></a>4. 创建「关于页」</h6><p>首次使用主题的「关于页」需要手动创建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p>
<p>修改后的文件示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">layout: about</span><br><span class="line">---</span><br><span class="line">这里写关于页的正文，支持 Markdown, HTML</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em><strong>现在重新运行 <code>hexo s</code>,应该就可以看到主题了</strong></em></p>
<h3 id="个性化页面展示"><a href="#个性化页面展示" class="headerlink" title="个性化页面展示"></a>个性化页面展示</h3><p><em><strong>注意 项目根目录如果有_config.fluid.yml文件，在&#x2F;themes&#x2F;fluid&#x2F;_config.yml配置不生效，解决办法，删除根目录config.fluid.yml文件或者复制&#x2F;themes&#x2F;fluid&#x2F;_config.yml文件内容到config.fluid.yml中</strong></em></p>
<h5 id="1-浏览器tab页名称"><a href="#1-浏览器tab页名称" class="headerlink" title="1. 浏览器tab页名称"></a>1. 浏览器tab页名称</h5><p>修改根目录下 <code>_config.yml</code> 中的 <code>title</code> 字段。换成你自己的信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">nerkeler&#x27;s</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;nerkeler的个人博客&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">nerkeler</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-博客标题"><a href="#2-博客标题" class="headerlink" title="2. 博客标题"></a>2. 博客标题</h5><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>blog_title</code> 字段。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导航栏的相关配置</span></span><br><span class="line"><span class="comment"># Navigation bar</span></span><br><span class="line"><span class="attr">navbar:</span></span><br><span class="line">  <span class="comment"># 导航栏左侧的标题，为空则按 hexo config 中 `title` 显示</span></span><br><span class="line">  <span class="comment"># The title on the left side of the navigation bar. If empty, it is based on `title` in hexo config</span></span><br><span class="line">  <span class="attr">blog_title:</span> <span class="string">&quot;nerkeler&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-主页正中间的文字"><a href="#3-主页正中间的文字" class="headerlink" title="3. 主页正中间的文字"></a>3. 主页正中间的文字</h5><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>text</code> 字段。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首页副标题的独立设置</span></span><br><span class="line"><span class="comment"># Independent config of home page subtitle</span></span><br><span class="line"><span class="attr">slogan:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 为空则按 hexo config.subtitle 显示</span></span><br><span class="line">  <span class="comment"># If empty, text based on `subtitle` in hexo config</span></span><br><span class="line">  <span class="attr">text:</span> <span class="string">&quot;nerkeler 的个人博客&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="添加阅读量统计"><a href="#添加阅读量统计" class="headerlink" title="添加阅读量统计"></a>添加阅读量统计</h4><p>参照教程，使用<code>LeanCloud</code>统计阅读量</p>
<h5 id="1-申请LeanCloud账号并创建应用"><a href="#1-申请LeanCloud账号并创建应用" class="headerlink" title="1. 申请LeanCloud账号并创建应用"></a>1. 申请LeanCloud账号并创建应用</h5><p>进入 <a href="https://console.leancloud.cn/">官网</a> 注册账号 -&gt; 完成实名认证 -&gt; 完成邮箱认证 -&gt; 创建应用，选择<code>开发版</code>即可，免费 -&gt; 名称随意如（个人博客应用）、描述随意，可不写 -&gt; 点击创建</p>
<h5 id="2、记录AppID-和-AppKey"><a href="#2、记录AppID-和-AppKey" class="headerlink" title="2、记录AppID 和 AppKey"></a>2、记录<code>AppID</code> 和 <code>AppKey</code></h5><p>设置 -&gt; 应用凭证 -&gt; <code>AppID</code> 和 <code>AppKey</code></p>
<h5 id="3、修改Fluid配置"><a href="#3、修改Fluid配置" class="headerlink" title="3、修改Fluid配置"></a>3、修改Fluid配置</h5><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p>
<h6 id="单篇文章阅读量计数"><a href="#单篇文章阅读量计数" class="headerlink" title="单篇文章阅读量计数"></a>单篇文章阅读量计数</h6><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 网页访问统计</span></span><br><span class="line"><span class="comment"># Analysis of website visitors</span></span><br><span class="line"><span class="attr">web_analytics:</span>  <span class="comment"># 网页访问统计</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置 <code>leancloud</code>的 <code>app_id</code> 和 <code>app_key</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># LeanCloud 计数统计，可用于 PV UV 展示，如果 `web_analytics: enable` 没有开启，PV UV 展示只会查询不会增加</span></span><br><span class="line"><span class="comment"># LeanCloud count statistics, which can be used for PV UV display. If `web_analytics: enable` is false, PV UV display will only query and not increase</span></span><br><span class="line"><span class="attr">leancloud:</span></span><br><span class="line">  <span class="attr">app_id:</span> <span class="string">你的appid</span></span><br><span class="line">  <span class="attr">app_key:</span> <span class="string">你的appkey</span></span><br><span class="line">  <span class="comment"># REST API 服务器地址，国际版不填</span></span><br><span class="line">  <span class="comment"># Only the Chinese mainland users need to set</span></span><br><span class="line">  <span class="attr">server_url:</span></span><br><span class="line">  <span class="comment"># 统计页面时获取路径的属性</span></span><br><span class="line">  <span class="comment"># Get the attribute of the page path during statistics</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">window.location.pathname</span></span><br><span class="line">  <span class="comment"># 开启后不统计本地路径( localhost 与 127.0.0.1 )</span></span><br><span class="line">  <span class="comment"># If true, ignore localhost &amp; 127.0.0.1</span></span><br><span class="line">  <span class="attr">ignore_local:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>打开计数功能，统计来源改为 <code>leancloud</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 浏览量计数</span></span><br><span class="line"><span class="comment"># Number of visits</span></span><br><span class="line"><span class="attr">views:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 统计数据来源</span></span><br><span class="line">  <span class="comment"># Data Source</span></span><br><span class="line">  <span class="comment"># Options: busuanzi | leancloud</span></span><br><span class="line">  <span class="attr">source:</span> <span class="string">&quot;leancloud&quot;</span></span><br></pre></td></tr></table></figure>

<h6 id="页面底部展示网站的-PV、UV-统计数"><a href="#页面底部展示网站的-PV、UV-统计数" class="headerlink" title="页面底部展示网站的 PV、UV 统计数"></a>页面底部展示网站的 PV、UV 统计数</h6><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 展示网站的 PV、UV 统计数</span></span><br><span class="line"><span class="comment"># Display website PV and UV statistics</span></span><br><span class="line"><span class="attr">statistics:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 统计数据来源，使用 leancloud 需要设置 `web_analytics: leancloud` 中的参数；使用 busuanzi 不需要额外设置，但是有时不稳定，另外本地运行时 busuanzi 显示统计数据很大属于正常现象，部署后会正常</span></span><br><span class="line">  <span class="comment"># Data source. If use leancloud, you need to set the parameter in `web_analytics: leancloud`</span></span><br><span class="line">  <span class="comment"># Options: busuanzi | leancloud</span></span><br><span class="line">  <span class="attr">source:</span> <span class="string">&quot;leancloud&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 国内大陆服务器的备案信息</span></span><br><span class="line"><span class="comment"># For Chinese mainland website policy, other areas keep disable</span></span><br></pre></td></tr></table></figure>

<h6 id="添加评论功能"><a href="#添加评论功能" class="headerlink" title="添加评论功能"></a>添加评论功能</h6><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 评论插件</span></span><br><span class="line"><span class="comment"># Comment plugin</span></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 指定的插件，需要同时设置对应插件的必要参数</span></span><br><span class="line">  <span class="comment"># The specified plugin needs to set the necessary parameters at the same time</span></span><br><span class="line">  <span class="comment"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">valine</span></span><br></pre></td></tr></table></figure>

<p>配置 <code>LeanCloud</code> 的 <code>appId</code> 和 <code>appkey</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># 基于 LeanCloud</span></span><br><span class="line"><span class="comment"># Based on LeanCloud</span></span><br><span class="line"><span class="comment"># See: https://valine.js.org/</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">你的appid</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="string">你的appkey</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">window.location.pathname</span></span><br><span class="line">  <span class="attr">placeholder:</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">&#x27;retro&#x27;</span></span><br><span class="line">  <span class="attr">meta:</span> [<span class="string">&#x27;nick&#x27;</span>, <span class="string">&#x27;mail&#x27;</span>, <span class="string">&#x27;link&#x27;</span>]</span><br><span class="line">  <span class="attr">requiredFields:</span> []</span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">&#x27;zh-CN&#x27;</span></span><br><span class="line">  <span class="attr">highlight:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">emojiCDN:</span></span><br><span class="line">  <span class="attr">emojiMaps:</span></span><br><span class="line">  <span class="attr">enableQQ:</span> <span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重新部署后，查看页面效果，各个功能是否开启，部署在本地时评论无法提交，会报跨域问题，发布到 <code>GitHub Pages</code> 上之后课正常提交评论</p>
<h3 id="发布到GitHub-Pages"><a href="#发布到GitHub-Pages" class="headerlink" title="发布到GitHub Pages"></a>发布到GitHub Pages</h3><p>这里直接用了教程方式一，不成功的可以区看方式二</p>
<h5 id="安装hexo-deployer-git："><a href="#安装hexo-deployer-git：" class="headerlink" title="安装hexo-deployer-git："></a>安装<code>hexo-deployer-git</code>：</h5><ul>
<li>&#96;&#96;&#96;<br>npm install hexo-deployer-git –save<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### `Github`新建token</span><br><span class="line"></span><br><span class="line">`Setting ---&gt; developer settings --&gt; personal access tokens --&gt; Tokens(classic) --&gt; Generate new token`</span><br><span class="line"></span><br><span class="line">***token 只显示一次，记录下来***</span><br><span class="line"></span><br><span class="line">修改根目录下的 `_config.yml`，配置 `GitHub` 相关信息</span><br><span class="line"></span><br><span class="line">```yml</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/nerkeler/nerkeler.github.io（换成你的）</span><br><span class="line">  branch: main</span><br><span class="line">  token: 你的token</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>部署到GitHub(<em><strong>更新和部署命令 很重要，第二种方式更新太麻烦</strong></em>)，<em>需要科学上网全局代理（如果带不开<code>github</code>)</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p><em><strong>部署成功后 浏览器访问自己的githubpage 测试是否成功</strong></em></p>
<h4 id="Hexo-admin后台管理"><a href="#Hexo-admin后台管理" class="headerlink" title="Hexo-admin后台管理"></a>Hexo-admin后台管理</h4><p>Hexo没有后台管理页面，这意味着我们只能通过本地生成文章并推送，很不方便，<a href="https://github.com/jaredly/hexo-admin">Hexo-admin</a>可以帮助我们后台编辑、发布文章，不需要用命令执行新建和编辑文章。<em><strong>但是无法Hexo-admin是动态页面，我们不能在githubpage上访问到</strong></em>。</p>
<h6 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install hexo-admin --save</span><br></pre></td></tr></table></figure>

<p>安装完成后，本地启动<code>Hexo</code>后访问  <a href="http://localhost:4000/admin">http://localhost:4000/admin</a> 即可进入后台页面，第一次进入后台后可在<strong>SETTING</strong>下输入<code>username</code>和<code>password</code>生成账号密码</p>
<p>输入内容后下滑，找到生成的代码，复制到“<code>_config.yml</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">admin:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">password_hash:</span> <span class="string">生成的密码串</span></span><br><span class="line">  <span class="attr">secret:</span> <span class="string">my</span> <span class="string">super</span> <span class="string">secret</span> <span class="string">phrase</span></span><br></pre></td></tr></table></figure>

<p>重启项目后访问即可登录，如果部署在githubpage上，那只能在本地使用，我觉得没有必要设置账户密码</p>
<h5 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h5><p>在hexo-admin 后台新建文章，右上角 点击设置图标  <code>Categories</code>为文章分类 <code>tags</code>为标签，点击publish即可发布，<em><strong>文章点击后既发布但是页面没有发生跳转</strong></em></p>
<h5 id="更新到Githubpage"><a href="#更新到Githubpage" class="headerlink" title="更新到Githubpage"></a>更新到<code>Githubpage</code></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>



<h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><h5 id="国内域名（我不清楚这样是否要备案）"><a href="#国内域名（我不清楚这样是否要备案）" class="headerlink" title="国内域名（我不清楚这样是否要备案）"></a>国内域名（我不清楚这样是否要备案）</h5><p>添加<code>githubPage</code>主机解析</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HOSTNAME	TYPE	ADDRESS / VALUE		DISTANCE/PRIO	</span><br><span class="line">			A		185.199.108.153			NA				</span><br><span class="line">			A		185.199.109.153			NA				</span><br><span class="line">			A		185.199.110.153			NA					</span><br><span class="line">			A		185.199.111.153			NA				</span><br></pre></td></tr></table></figure>

<p>进入GitHub博客仓库主页，</p>
<p><code>SETTING ----&gt; Pages  ----&gt; Custom domain </code></p>
<p>填写自己的域名，打开 下方<strong>enforce Https</strong> 如果显示错误也没有关系，不用管</p>
<h5 id="国外域名-（cloudFlare-代理"><a href="#国外域名-（cloudFlare-代理" class="headerlink" title="国外域名 （cloudFlare)代理"></a>国外域名 （cloudFlare)代理</h5><h6 id="注册CloudFlare"><a href="#注册CloudFlare" class="headerlink" title="注册CloudFlare"></a>注册CloudFlare</h6><p><code>Websites --&gt;   add a site </code></p>
<p>将自己的域名添加进CloudFlare，并设置域名解析的dns (NameServer)按照CloudFlare 指示的步骤设置好，打开小云朵（使用CloudFlare代理，解决githubPage访问问题）</p>
<p>CloudFlare添加如下记录(记得打开小云朵)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">A		185.199.108.153			NA				</span><br><span class="line">A		185.199.109.153			NA				</span><br><span class="line">A		185.199.110.153			NA					</span><br><span class="line">A		185.199.111.153			NA		</span><br></pre></td></tr></table></figure>

<p>点击SSL&#x2F;TLS  设置成Full  (显示如：Your SSL&#x2F;TLS encryption mode is Full）</p>
<p>再次测试域名访问，应该就成功了，如果无法打开网页，点击chrome&#x2F;edge无痕窗口重新测试一遍，仍然无法访问，win+r 输入cmd  输入下面的命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ping 你的域名 </span><br></pre></td></tr></table></figure>

<p>如果能够ping通，稍等一会应该就好了，还不行，请检查上面的步骤</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池</title>
    <url>/2023/06/11/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h1><p><em><strong>以下内容为阅读《JAVA并发编程的艺术》学习总结 笔记</strong></em></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序 都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处。</p>
<h4 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h4><ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等待线程创建就能立即执行</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不久会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。</li>
</ul>
<h3 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h3><h4 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h4><p>我们可以通过<code>ThreadPoolExecutor</code>构造方法生成一个线程池对象，<strong>移除了内部代码，只留下了构造参数</strong>，便于理解，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>参数对应关系</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>corePoolSize</code></td>
<td>核心线程数</td>
</tr>
<tr>
<td><code>maximumPoolSize</code></td>
<td>最大线程数</td>
</tr>
<tr>
<td><code>keepAliveTime</code></td>
<td>线程活动保持时间</td>
</tr>
<tr>
<td><code>TimeUnit</code></td>
<td>线程活动保持时间的单位</td>
</tr>
<tr>
<td><code>BlockingQueue</code><Runnable></td>
<td>任务队列</td>
</tr>
<tr>
<td><code>ThreadFactory</code></td>
<td>线程工厂</td>
</tr>
<tr>
<td><code>RejectedExecutionHandler</code></td>
<td>拒绝策略</td>
</tr>
</tbody></table>
<p>大致明白参数意义后，我们说一下线程池新建一个线程的过程</p>
<p>先看一下线程池的执行示意图</p>
<ol>
<li>主线程执行<code>execute</code>()提交一个新线程，首先进入核心线程池<code>corePoolSize</code>并判断是否已满，如果未满则新建一个线程<strong>（注意，执行这一步骤 需要获取全局锁）。</strong></li>
<li>如果核心线程池已满，则进入阻塞队列<code>BlockingQueue</code>进行判断是否已满，如果未满则插入队列（队列保持先进先出的顺序执行 ）</li>
<li>如果阻塞队列已满，则判断线程池是否达到最大线程数量<code>maximumPoolSize</code>，如果没有，则新建线程<strong>（注意，执行这一步骤 需要获取全局锁）。</strong></li>
<li>如果达到最大线程数量，则执行拒绝策略<code>RejectedExecutionHandler</code></li>
</ol>
<p><img src="https://pic.imgdb.cn/item/64807dd91ddac507cc2c89a9.png"></p>
<p>如果将上述描述转化成流程图则为</p>
<p><img src="https://pic.imgdb.cn/item/64807fbf1ddac507cc2f94cf.png"></p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>上面的流程分析让我们很直观地了解了线程池的工作原理，让我们再通过源代 码来看看是如何实现的，线程池执行任务的方法如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否小于核心线程数，小于执行当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则尝试加入阻塞队列中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后尝试加入最大线程中</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="工作线程"><a href="#工作线程" class="headerlink" title="工作线程"></a>工作线程</h4><p>线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列中的任务来执行，我们可以从Worker类的run()方法里看到这点。</p>
<p><em><strong>只关注while循环和内部<code>task.run</code>即可</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    runWorker(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 二次验证线程是否中断或停止</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 线程执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                    afterExecute(task, <span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    afterExecute(task, ex);</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadPoolExecutor</code>中线程执行任务的示意图如下</p>
<img src="https://pic.imgdb.cn/item/6481703c1ddac507cc81ba88.png">

<p><strong>线程池中得先成功执行任务份两种情况</strong></p>
<ul>
<li>在execute()方法中创建一个线程时，会让这个线程执行当前任务</li>
<li>这个线程执行完上图中1得任务后，会反复从<code>BlockingQueue</code>获取任务来执行</li>
</ul>
<h4 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h4><h5 id="corePoolSize（核心线程数）"><a href="#corePoolSize（核心线程数）" class="headerlink" title="corePoolSize（核心线程数）"></a><code>corePoolSize</code>（核心线程数）</h5><p>当提交一个任务到线程池中时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等待需要执行的任务数大于线程池基本大小（核心线程数）时就不在创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p>
<h5 id="runnableTaskQueue（任务队列）"><a href="#runnableTaskQueue（任务队列）" class="headerlink" title="runnableTaskQueue（任务队列）"></a><code>runnableTaskQueue</code>（任务队列）</h5><p>用于保存等待执行的任务的阻塞队列。有以下几种</p>
<ul>
<li><code>ArrayBlockingQueue</code>: 一个基于数组结构的有界阻塞队列，按照FIFO（first in first out)先进先出的原则对元素进行排序。</li>
<li><code>LinkedBlockingQueue</code>:一个基于链表结构的阻塞队列，也是按照FIFO 原则排序元素，吞吐量通常高于<code>ArrayBlockingQueue</code>。静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列。</li>
<li><code>SynchronousQueue</code>: 一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<code>LinkedBlockingQueue</code>,静态工厂方法<code>Executors.newCachedThreadPool</code>使用了这个队列</li>
<li><code>ProirityBlockingQueue</code>:一个具有优先级的无限阻塞队列</li>
</ul>
<h5 id="maximumPoolSize（最大线程数）"><a href="#maximumPoolSize（最大线程数）" class="headerlink" title="maximumPoolSize（最大线程数）"></a><code>maximumPoolSize</code>（最大线程数）</h5><p>线程池允许创建的最大线程数。如果核心线程和队列都已经满了，并且已创建的线程数小于最大线程数，也就是上图中3这种情况，后续提交的线程则会创建新线程，<strong>当使用无界的任务队列时，提交的线程会无限阻塞在任务队列中，这个参数就失去了意义。</strong></p>
<h5 id="ThreadFactory（线程工厂）"><a href="#ThreadFactory（线程工厂）" class="headerlink" title="ThreadFactory（线程工厂）"></a><code>ThreadFactory</code>（线程工厂）</h5><p><code>ThreadFactory</code> 是一个接口，用于创建线程的工厂。它提供了一种创建和定制线程的方式，让你能够对线程进行更多的控制和管理。例如自定义线程名称、设置线程优先级、设置线程组等。</p>
<h5 id="RejectedExecutionHandler（拒绝策略）"><a href="#RejectedExecutionHandler（拒绝策略）" class="headerlink" title="RejectedExecutionHandler（拒绝策略）"></a><code>RejectedExecutionHandler</code>（拒绝策略）</h5><p>当队列和线程池都满了，说明明线程池处于饱和状态，那么必须才需一种策略处理提交的新任务。默认请情况下使用的时AbortPolicy,表示无法处理新任务时抛出异常。自JDK1.5 Java线程池提供了4中策略</p>
<ul>
<li><code>AbortPolicy</code> 直接抛出异常</li>
<li><code>CallerRunsPolicy</code> 只用调用者所在的线程运行任务</li>
<li><code>DiscardOldestPolicy</code> 丢弃队列里最旧的任务也就是最早添加的一个任务，并尝试执行当前任务</li>
<li><code>DiscardPolicy</code> 不处理  直接丢弃</li>
</ul>
<p>除此之外，我们可以根据业务场景自己实现<code>RejectedExecutionHandler</code>接口自定义策略，比如记录日志或持久化不能处理的任务</p>
<h5 id="keepAliveTime（存活时间）"><a href="#keepAliveTime（存活时间）" class="headerlink" title="keepAliveTime（存活时间）"></a><code>keepAliveTime</code>（存活时间）</h5><p>线程池对的工作线程空闲后，保持存活的时间，线程在存活时间内可被重复利用，如果我们执行任务的时间比较短，调大存活时间可以提高线程利用率，避免线程的重新启动和终止所产生的额外时间消耗</p>
<h5 id="TimeUnit-存活时间单位"><a href="#TimeUnit-存活时间单位" class="headerlink" title="TimeUnit(存活时间单位)"></a><code>TimeUnit</code>(存活时间单位)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.concurrent.TimeUnit</span><br></pre></td></tr></table></figure>

<p>可选</p>
<ul>
<li>SECONDS                           秒</li>
<li>DAYS                                   天</li>
<li>HOURS                               小时</li>
<li>MICROSECONDS              微秒</li>
<li>MILLISECONDS                 毫秒</li>
<li>MINUTES                           分钟</li>
<li>NANOSECONDS               纳秒</li>
</ul>
<h4 id="提交线程任务"><a href="#提交线程任务" class="headerlink" title="提交线程任务"></a>提交线程任务</h4><p>线程池提交任务使用execute()方法和submit()方法，区别在于execute()方法无返回值，submit()方法可以获取线程执行返回值，它返回一个Future接口对象，可以使用<code>future.get()</code>阻塞线程获取返回值</p>
<h5 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h5><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span></span><br></pre></td></tr></table></figure>

<p>可以看到execute()接收一个Runnable的实例对象，也无返回值，所以无法判断任务是否是否被线程池执行成功（如果线程没有打印或日志的情况下），一个小例子如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    executorService.execute(()-&gt; System.out.println(<span class="string">&quot;提交新线程成功&quot;</span>));</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果不言而喻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">提交新线程成功</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h5 id="submit"><a href="#submit" class="headerlink" title="submit()"></a>submit()</h5><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到submit()方法返回一个Future接口对象，我们可以通过Future的get()方法获取返回值，当然get()方法会阻塞当前线程</p>
<p>一个小例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    Future&lt;String&gt; submit = executorService.submit(() -&gt; <span class="string">&quot;提交新线程成功&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(submit.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">提交新线程成功</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><p>关闭线程池可以使用shutdown或shutdownNow方法，他们的原理是遍历线程池的工作线程，然后逐个调用线程的interrupt方法来中断线程。</p>
<p>区别在于shutdownNow会先将线程池的状态设置成stop,然后尝试停止所有正在执行或暂停的任务线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行的任务线程</p>
<p>只要调用这两个方法中的任意一个，<code>isShutdown</code>方法就会返回<code>ture</code>,当所有任务都已经关闭后，才表示线程池关闭成功，这个时候调用<code>idTerminaed</code>方法会返回<code>true</code>。通常使用shutdown方法关闭线程。</p>
<h4 id="合理地配置线程池"><a href="#合理地配置线程池" class="headerlink" title="合理地配置线程池"></a>合理地配置线程池</h4><p>要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。</p>
<ul>
<li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务。 </li>
<li>任务的优先级：高、中和低。 ·任务的执行时间：长、中和短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li>
</ul>
<p>性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的 线程，如配置<code>**Ncpu+1**</code>个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配 置尽可能多的线程，如<code>**2*Ncpu**</code>。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务 和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量 将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过 <code>**Runtime.getRuntime().availableProcessors()**</code>方法获得当前设备的CPU个数。</p>
<ul>
<li>优先级不同的任务可以使用优先级队列<code>PriorityBlockingQueue</code>来处理。它可以让优先级高 的任务先执行。</li>
<li>执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让 执行时间短的任务先执行。</li>
<li>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越 长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。</li>
</ul>
<p><em><strong>PS:</strong></em></p>
<p>***	如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能 执行。***</p>
<p>​	*<strong>建议使用有界队列</strong>,有界队列能增加系统的稳定性和预警能力。</p>
<h4 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h4><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。</p>
<p>可以通过线程池提供的参数进行监控，在监控线程池的 时候可以使用以下属性。 </p>
<ul>
<li><code>taskCount</code>：线程池需要执行的任务数量。 </li>
<li><code>completedTaskCount</code>：线程池在运行过程中已完成的任务数量，小于或等于<code>taskCount</code>。 </li>
<li><code>largestPoolSize</code>：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是 否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</li>
<li><code>getPoolSize</code>：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销 毁，所以这个大小只增不减。 </li>
<li><code>getActiveCount</code>：获取活动的线程数。</li>
</ul>
<p>通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的 <code>beforeExecute</code>、<code>afterExecute</code>和<code>terminated</code>方法，也可以在任务执行前、执行后和线程池关闭前执 行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。 这几个方法在线程池里是空方法。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java日期小工具类</title>
    <url>/2023/03/30/Java%E6%97%A5%E6%9C%9F%E5%B0%8F%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Java-日期月份处理小工具类"><a href="#Java-日期月份处理小工具类" class="headerlink" title="Java 日期月份处理小工具类"></a>Java 日期月份处理小工具类</h2><p>再<code>sql</code>的月份和日期查询中，可能会需要将日期或者月份相应推迟&#x2F;提前一天或一段时间，当然，这个逻辑放在<code>sql</code>中也是可以的，具体还是要看需求是否合适。分享三个小方法，一个是计算月份差、日期加减一&#x2F;多天、月份加减一&#x2F;多天</p>
<h4 id="月份差"><a href="#月份差" class="headerlink" title="月份差"></a>月份差</h4><h6 id="输入参数："><a href="#输入参数：" class="headerlink" title="输入参数："></a>输入参数：</h6><ul>
<li><code>startMonth</code><ul>
<li>字符串，格式应该为<code>yyyy-MM</code>对应下面<code>SimpleDateFormat(&quot;yyyy-MM&quot;);</code>可根据需要更改格式</li>
</ul>
</li>
<li><code>endMonth</code><ul>
<li>字符串，格式应该为<code>yyyy-MM</code>对应下面<code>SimpleDateFormat(&quot;yyyy-MM&quot;);</code>可根据需要更改格式</li>
</ul>
</li>
</ul>
<h6 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h6><ul>
<li>diff<ul>
<li>整型，月份差值，如3月-6月  返回3</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">getMonthDiff</span><span class="params">(String startMonth, String endMonth)</span> &#123;</span><br><span class="line">	<span class="type">DateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM&quot;</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">end</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start = dateFormat.parse(startMonth);</span><br><span class="line">        end = dateFormat.parse(endMonth);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">c1</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">c2</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    c1.setTime(start);</span><br><span class="line">    c2.setTime(end);</span><br><span class="line">    <span class="type">int</span> <span class="variable">year1</span> <span class="operator">=</span> c1.get(Calendar.YEAR);</span><br><span class="line">    <span class="type">int</span> <span class="variable">year2</span> <span class="operator">=</span> c2.get(Calendar.YEAR);</span><br><span class="line">    <span class="type">int</span> <span class="variable">month1</span> <span class="operator">=</span> c1.get(Calendar.MONTH);</span><br><span class="line">    <span class="type">int</span> <span class="variable">month2</span> <span class="operator">=</span> c2.get(Calendar.MONTH);</span><br><span class="line">    <span class="type">int</span> <span class="variable">day1</span> <span class="operator">=</span> c1.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    <span class="type">int</span> <span class="variable">day2</span> <span class="operator">=</span> c2.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    <span class="comment">// 获取年的差值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">yearInterval</span> <span class="operator">=</span> year1 - year2;</span><br><span class="line">    <span class="comment">// 如果 d1的 月-日 小于 d2的 月-日 那么 yearInterval-- 这样就得到了相差的年数</span></span><br><span class="line">    <span class="keyword">if</span> (month1 &lt; month2 || month1 == month2 &amp;&amp; day1 &lt; day2) &#123;</span><br><span class="line">        yearInterval--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取月数差值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">monthInterval</span> <span class="operator">=</span> (month1 + <span class="number">12</span>) - month2;</span><br><span class="line">    <span class="keyword">if</span> (day1 &lt; day2) &#123;</span><br><span class="line">        monthInterval--;</span><br><span class="line">    &#125;</span><br><span class="line">    monthInterval %= <span class="number">12</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">monthsDiff</span> <span class="operator">=</span> Math.abs(yearInterval * <span class="number">12</span> + monthInterval);</span><br><span class="line">    <span class="keyword">return</span> monthsDiff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="日期加减"><a href="#日期加减" class="headerlink" title="日期加减"></a>日期加减</h4><h6 id="输入参数：-1"><a href="#输入参数：-1" class="headerlink" title="输入参数："></a>输入参数：</h6><ul>
<li><code>day</code><ul>
<li>字符串，日期，格式应该为<code>yyyy-MM-dd</code>对应下面<code>SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</code>可根据需要更改格式</li>
</ul>
</li>
<li><code>num</code><ul>
<li>整型，偏移量   为正 时间往后加，负  时间往前推</li>
</ul>
</li>
</ul>
<h6 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h6><ul>
<li>date<ul>
<li>String，格式处理后的时间，如3月1-3月4  返回3</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">dayFormat</span><span class="params">(String day, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">       <span class="type">DateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">       <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           date = dateFormat.parse(day);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">       c.setTime(date);</span><br><span class="line">       c.add(Calendar.DATE,num);</span><br><span class="line">       date = c.getTime();</span><br><span class="line">       <span class="keyword">return</span>  dateFormat.format(date);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="月份加减"><a href="#月份加减" class="headerlink" title="月份加减"></a>月份加减</h4><h6 id="输入参数：-2"><a href="#输入参数：-2" class="headerlink" title="输入参数："></a>输入参数：</h6><ul>
<li><code>day</code><ul>
<li>字符串，日期，格式应该为<code>yyyy-MM</code>对应下面<code>SimpleDateFormat(&quot;yyyy-MM&quot;);</code>可根据需要更改格式</li>
</ul>
</li>
<li><code>num</code><ul>
<li>整型，偏移量   为正 月份往后加，负  时间往前推</li>
</ul>
</li>
</ul>
<h6 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h6><ul>
<li>date<ul>
<li>String，格式处理后的时间，如3月-6月  返回3</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">monthFormat</span><span class="params">(String month, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">       <span class="type">DateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM&quot;</span>);</span><br><span class="line">       <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           date = dateFormat.parse(month);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">       c.setTime(date);</span><br><span class="line">       c.add(Calendar.MONTH,num);</span><br><span class="line">       date = c.getTime();</span><br><span class="line">       <span class="keyword">return</span>  dateFormat.format(date);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>最近太水了，已经托更一周了，这次又是水了一篇，争取下次好好写一篇</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Future和CompletableFuture</title>
    <url>/2023/06/04/UntitledFuture%E5%92%8CCompletableFuture/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Future和CompletableFuture"><a href="#Future和CompletableFuture" class="headerlink" title="Future和CompletableFuture"></a>Future和CompletableFuture</h1><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @since 1.5</span></span><br><span class="line"><span class="comment">* @author Doug Lea</span></span><br><span class="line"><span class="comment">* @param &lt;V&gt; The result type returned by this FutureTask&#x27;s &#123;@code get&#125; methods</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; &#123;</span><br></pre></td></tr></table></figure>

<p>Future接口在Java 5中被引入，设计初衷是对将来某个时刻会发生的结果进行建模。它建模 了一种异步计算，返回一个执行运算结果的引用，当运算结束后，这个引用被返回给调用方。</p>
<h4 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">       <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">       <span class="comment">// 把需要耗时得事情交给 future 中得线程池</span></span><br><span class="line">       Future&lt;Double&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">           TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;doSomeLongComputation&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> ThreadLocalRandom.current().nextDouble();</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">// 做一些其他的事情</span></span><br><span class="line">       System.out.println(<span class="string">&quot;doSomethingElse&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">Double</span> <span class="variable">result</span> <span class="operator">=</span> future.get(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">           System.out.println(result);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="comment">// 计算抛出一个异常</span></span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 关闭线程池</span></span><br><span class="line">       executor.shutdown();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>程序结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doSomethingElse</span><br><span class="line">doSomeLongComputation</span><br><span class="line"><span class="number">0.3039716200549002</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>上述代码让我们可以以并发得方式调用另一个线程执行耗时操作得同时，也可以去执行一些其他的任务。启动异步任务，后我们可以调用它得get()方法获取操作返回值，如果通过get获取时程序在传入规定时间还没有返回值，则会抛出异常，获取时还没有生成返回值则会进行阻塞。</p>
<p><img src="https://pic.imgdb.cn/item/6475a5ecf024cca1734dcc0b.png"></p>
<p>理解了上述执行流程，我们看一下Future接口提供的几个基本方法</p>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td>cancel(<code>boolean</code> <code>mayInterruptIfRunning</code>) 尝试取消执行此任务。</td>
</tr>
<tr>
<td>V</td>
<td>get() 等待计算完成，然后检索其结果。</td>
</tr>
<tr>
<td>V</td>
<td>get(long timeout, <code>TimeUnit</code> unit) 如果需要等待最多在给定的时间计算完成，然后检索其结果（如果可用）。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>isCancelled() 如果此任务在正常完成之前被取消，则返回 true 。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>isDone() 返回 true如果任务已完成。</td>
</tr>
</tbody></table>
<p>我们看到get方法有两个重载得方法，get(long timeout,<code>TimeUnit</code> unit) 和get(）的区别是如果在指定时间内没有得到结果的返回值，则会抛出异常，程序会继续运行，而get()方法则会阻塞主线程进行等待，知道获取返回值，如果异步线程是一个极其耗费时间的操作，则会导致主线程进入漫长的等待</p>
<h4 id="Future-接口的局限性"><a href="#Future-接口的局限性" class="headerlink" title="Future 接口的局限性"></a><strong>Future 接口的局限性</strong></h4><p>通过上述例子可以看到Future接口可能会导致程序进入漫长的等待或者直接抛弃获取值操作，虽然我们可以通过isDone()检测程序是否运行完毕，但是始终还是存在一定的运行阻塞与等待<br>如果我们有这样一个需求：我们需要完成两个计算任务，当前一个计算任务结束后，需要将改计算的结果通知到另一个长时间运行的计算任务，当两个计算任务都结束后，将两个计算任务合并后输出。 新的<code>CompletableFuture</code>类  会很方便的解决这类问题。</p>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a><strong><code>CompletableFuture</code></strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFuture</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Future</span>&lt;T&gt;, CompletionStage&lt;T&gt; </span><br></pre></td></tr></table></figure>

<p>查看类图可知，<code>CompletableFuture</code> 实现了Future接口和<code>CompletionStage</code>接口，也就是说在原有Future接口的基础上提供了一些扩展，自然功能更为强大</p>
<p><img src="https://pic.imgdb.cn/item/6476a114f024cca1733367f4.png"></p>
<h4 id="CompletionStage接口"><a href="#CompletionStage接口" class="headerlink" title="CompletionStage接口"></a><code>CompletionStage</code>接口</h4><p><code>CompletionStage</code> 是 Java 8 引入的接口，用于支持异步计算和处理结果的操作。它是 Java 中的一个 Future 接口的扩展，并提供了更强大的异步编程模型</p>
<ol>
<li><code>CompletionStage</code>代表异步计算过程中的某一个阶段,一个阶段完成后可能会触发另外一个阶段</li>
<li>一个阶段的计算执行可以是一个<code>Funcation</code>、Consumer、Runnable。比如:<code>stage.thenApply (x-&gt;square(x)).thenAccept(x-&gt;System.out.println(x)).thenRun(()-&gt;&#123;System.out.println()&#125;);</code></li>
<li>一个阶段的执行可能是被单个阶段的完成触发,也可能是由多个阶段一起触发.有些类似Linux系统的管道分隔符传参数</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个异步任务</span></span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello, CompletableFuture!&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册任务完成后的回调</span></span><br><span class="line">        future.thenAccept(result -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task completed: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread continues to execute...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Main thread continues to execute...</span><br><span class="line">Task completed: Hello, CompletableFuture!</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>如上所示<code>CompletableFuture</code>使用静态方法构造<code>CompletableFuture</code>对象，常用的静态构造方法如下所示</p>
<h4 id="常用静态构造方法"><a href="#常用静态构造方法" class="headerlink" title="常用静态构造方法"></a><strong>常用静态构造方法</strong></h4><table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Modifier and Type</th>
<th>describe</th>
</tr>
</thead>
<tbody><tr>
<td><code>CompletableFuture</code><Void></td>
<td><code>runAsync</code>(<code>Runnablerunnable</code>)</td>
<td>无返回值</td>
</tr>
<tr>
<td><code>CompletableFuture</code><Void></td>
<td><code>runAsync</code>(<code>Runnablerunnable</code>, <code>Executorexecutor</code>)</td>
<td>无返回值，指定线程池</td>
</tr>
<tr>
<td><code>CompletableFuture</code><U></td>
<td>supplyAsync(Supplier<U>supplier)</td>
<td>有返回值</td>
</tr>
<tr>
<td><code>CompletableFuture</code><U></td>
<td>supplyAsync(Supplier<U>supplier, Executor executor)</td>
<td>有返回值，指定线程池</td>
</tr>
</tbody></table>
<p>为什么不用构造方法呢？我们看一下jdk文档的描述</p>
<h4 id="构造方法摘要"><a href="#构造方法摘要" class="headerlink" title="构造方法摘要"></a>构造方法摘要</h4><table>
<thead>
<tr>
<th>Constructor and Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>CompletableFuture</code>() 创建一个新的不完整的<code>CompletableFuture</code>。</td>
</tr>
</tbody></table>
<p>默认空参构造器只能新建一个不完整的<code>CompletableFuture</code>对象，原因简略看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a new CompletableFuture that is asynchronously completed</span></span><br><span class="line"><span class="comment"> * by a task running in the &#123;<span class="doctag">@link</span> ForkJoinPool#commonPool()&#125; with</span></span><br><span class="line"><span class="comment"> * the value obtained by calling the given Supplier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> supplier a function returning the value to be used</span></span><br><span class="line"><span class="comment"> * to complete the returned CompletableFuture</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;U&gt; the function&#x27;s return type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new CompletableFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">asyncSupplyStage</span><span class="params">(Executor e,</span></span><br><span class="line"><span class="params">                                                 Supplier&lt;U&gt; f)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    CompletableFuture&lt;U&gt; d = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;U&gt;();</span><br><span class="line">    e.execute(<span class="keyword">new</span> <span class="title class_">AsyncSupply</span>&lt;U&gt;(d, f));</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>supplyAsync</code>静态方法在执行时，也new了一个新的<code>ComPletableFuture</code>对象，不同的是，<code>supplyAsync</code>方法调用<code>asyncSupplyStage</code>后使用e.<code>execute</code> 开启了线程。所以<code>ComPletableFuture</code> 空参构造只是一个<code>ComPletableFuture</code>对象，还需要进一步开启线程，其他静态构造方法原理一致。</p>
<h4 id="线程池相关"><a href="#线程池相关" class="headerlink" title="线程池相关"></a><strong>线程池相关</strong></h4><p>通过上面的构造方法可以看到，相同两个方法名之间的区别就是是否指定了新的线程池，如果没有指定线程池，则会使用<code>ComPletableFuture</code>内置的线程池<code>ForkJoinPool</code>。</p>
<p>实现源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default executor -- ForkJoinPool.commonPool() unless it cannot</span></span><br><span class="line"><span class="comment"> * support parallelism.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">asyncPool</span> <span class="operator">=</span> useCommonPool ?</span><br><span class="line">    ForkJoinPool.commonPool() : <span class="keyword">new</span> <span class="title class_">ThreadPerTaskExecutor</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Fallback if ForkJoinPool.commonPool() cannot support parallelism */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span> &#123; <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里只是做了一个三目运算来判断是否指定了线程池。</p>
<h4 id="简单实践"><a href="#简单实践" class="headerlink" title="简单实践"></a>简单实践</h4><p>我们指定一个字符串列表，取出每个字符串并获得第一个字符 ，等待一秒后，与一个随机数相乘, 比如字符串”hello” ,取出h，等待一秒后，用h的ASCII码与一个随机浮点数相乘。</p>
<h5 id="Stream流方式"><a href="#Stream流方式" class="headerlink" title="Stream流方式"></a>Stream流方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;BestPrice&quot;</span>, <span class="string">&quot;LetsSaveBig&quot;</span>, <span class="string">&quot;MyFavoriteShop&quot;</span>, <span class="string">&quot;BuyItAll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    List&lt;Double&gt; collect = strings.stream()</span><br><span class="line">            .map(s -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> s.charAt(<span class="number">0</span>) * ThreadLocalRandom.current().nextDouble();</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(end - start);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行时间为： <strong>4108毫秒</strong></p>
<h5 id="并行流方式"><a href="#并行流方式" class="headerlink" title="并行流方式"></a>并行流方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;BestPrice&quot;</span>, <span class="string">&quot;LetsSaveBig&quot;</span>, <span class="string">&quot;MyFavoriteShop&quot;</span>, <span class="string">&quot;BuyItAll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    List&lt;Double&gt; collects = strings.parallelStream()</span><br><span class="line">            .map(s -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> s.charAt(<span class="number">0</span>) * ThreadLocalRandom.current().nextDouble();</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(end - start);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>改动之处：stream（）—》parallelStream()</strong></em></p>
<p>执行时间为：<strong>1067毫秒</strong></p>
<h5 id="CompletableFuture实现"><a href="#CompletableFuture实现" class="headerlink" title="CompletableFuture实现"></a>CompletableFuture实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;BestPrice&quot;</span>, <span class="string">&quot;LetsSaveBig&quot;</span>, <span class="string">&quot;MyFavoriteShop&quot;</span>, <span class="string">&quot;BuyItAll&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    List&lt;CompletableFuture&lt;Double&gt;&gt; collect = strings.stream()</span><br><span class="line">            .map(s -&gt;</span><br><span class="line">                    CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> s.charAt(<span class="number">0</span>) * ThreadLocalRandom.current().nextDouble();</span><br><span class="line">                    &#125;)</span><br><span class="line">            )</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    List&lt;Double&gt; collect1 = collect.stream()</span><br><span class="line">            .map(CompletableFuture::join)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(end - start);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行时间为：<strong>1072毫秒</strong></p>
<p>可以看到，使用并行流和CompletableFuture实现比原先顺序流要快了很多，而并行流和CompletableFuture好像并没有多大差别。这是因为什么呢？</p>
<h5 id="并行流和CompletableFuture差别"><a href="#并行流和CompletableFuture差别" class="headerlink" title="并行流和CompletableFuture差别"></a>并行流和CompletableFuture差别</h5><p>并行流和CompletableFuture内部采用的是同样的通用线程池也就是上文说的<strong>ForkJoinPool</strong> ，默认都使用固定数目的线程，具体线程数取决于<code>Runtime.getRuntime().availableProcessors()</code>的返回值。</p>
<p>而CompletableFuture不止可以使用默认的线程池，我们也可以根据自己的实际需求提供对应的线程池对象，尤其是线程池的大小，这是并行流API无法提供的，而CompletableFuture也并非仅仅为了实现多线程，更重要是是弥补Future接口使用带来的缺陷和不足。</p>
<h5 id="执行流程图"><a href="#执行流程图" class="headerlink" title="执行流程图"></a>执行流程图</h5><p><img src="https://pic.imgdb.cn/item/64795c9ff024cca173266bdd.png"></p>
<p>而CompletableFuture实现则是先用顺序流返回了一个CompletableFuture对象，相当于收集了一个多线程集合，然后顺序启动多线程。</p>
<h4 id="CompletableFuture-常用方法"><a href="#CompletableFuture-常用方法" class="headerlink" title="CompletableFuture 常用方法"></a>CompletableFuture 常用方法</h4><h5 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h5><ul>
<li>public T get( )  													实现了Future接口的方法，等待线程执行获取结果，可能会阻塞线程去等待</li>
<li>public T get(long timeout, TimeUnit unit)     实现了Future接口的方法，等待线程获取结果，超过指定时间抛出异常</li>
<li>public T getNow(T valuelfAbsent)                   相当于三元运算，需要立即获取结果，如果没有则使用valuelfAbsent</li>
<li>public T join( ):                                                     join方法和get( ) 方法作用几乎,不同的是,join方法不抛出异常</li>
</ul>
<p>简单演示一下getNow()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">      CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">now1</span> <span class="operator">=</span> future.getNow(<span class="number">3</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>);  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">Integer</span> <span class="variable">now2</span> <span class="operator">=</span> future.getNow(<span class="number">3</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;now1: &quot;</span>+ now1);</span><br><span class="line">      System.out.println(<span class="string">&quot;now2: &quot;</span>+ now2);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">now1: <span class="number">3</span></span><br><span class="line">now2: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h5 id="对计算结果进行处理"><a href="#对计算结果进行处理" class="headerlink" title="对计算结果进行处理"></a>对计算结果进行处理</h5><h6 id="thenApply、handle"><a href="#thenApply、handle" class="headerlink" title="(thenApply、handle)"></a><strong>(thenApply、handle)</strong></h6><p>**<code>thenApply(Function&lt;? super T,? extends U&gt; fn)</code>**：</p>
<ul>
<li>该方法用于在异步任务完成后对结果进行转换，返回一个新的 <code>CompletableFuture</code> 对象。</li>
<li>它接受一个 <code>Function</code> 参数，该函数将任务的结果类型 <code>T</code> 转换为类型 <code>U</code>。</li>
<li><code>thenApply()</code> 方法会等待当前任务完成，并将任务的结果作为参数传递给函数，然后返回一个新的 <code>CompletableFuture</code> 对象，该对象表示对结果进行转换后的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future1 = future.thenApply(String::length);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future2 = future1.thenApply(s -&gt; s * <span class="number">100</span> +<span class="number">88</span>);</span><br><span class="line">    System.out.println(future2.join());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">588</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可以看到thenApply就是把上一个结果传递给下一个<code>CompletableFuture</code> 对象，相当于链式调用。</p>
<p>上述代码也可以这样实现，也就是链式调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">            .thenApply(String::length)</span><br><span class="line">            .thenApply(s -&gt; s * <span class="number">100</span> +<span class="number">88</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(future.join());</span><br></pre></td></tr></table></figure>

<p>**<code>handle(BiFunction&lt;? super T,Throwable,? extends U&gt; fn)</code>**：</p>
<ul>
<li>该方法用于在异步任务完成后对结果进行处理，无论任务是否发生异常，都会执行处理逻辑，并返回一个新的 <code>CompletableFuture</code> 对象。</li>
<li>它接受一个 <code>BiFunction</code> 参数，该函数接受任务的结果类型 <code>T</code> 和可能发生的异常类型 <code>Throwable</code>，并返回类型 <code>U</code>。</li>
<li><code>handle()</code> 方法会等待当前任务完成，并将任务的结果或异常作为参数传递给函数，然后返回一个新的 <code>CompletableFuture</code> 对象，该对象表示处理后的结果。</li>
</ul>
<p>handle方法和thenApply方法类似，不同的是handle在中间操作时出现异常不会停止任务，而是把异常传递给下一个Completable对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>)</span><br><span class="line">                    .handle((result, ex) -&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;</span><br><span class="line">                                System.out.println(<span class="string">&quot;Exception occurred: &quot;</span> + ex);</span><br><span class="line">                                <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 处理异常情况，返回默认值</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">return</span> result * <span class="number">2</span>;  <span class="comment">// 处理正常情况，返回结果的两倍</span></span><br><span class="line">                            &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(future.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>稍微改动一点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line">                .handle((result, ex) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;Exception occurred: &quot;</span> + ex);</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 处理异常情况，返回默认值</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> result * <span class="number">2</span>;  <span class="comment">// 处理正常情况，返回结果的两倍</span></span><br><span class="line">                        &#125;</span><br><span class="line">                 &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(future.join());</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception occurred: java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>也就是出现了异常并捕获，但是并没有影响结果执行。</p>
<h5 id="对计算结果进行消费"><a href="#对计算结果进行消费" class="headerlink" title="对计算结果进行消费"></a>对计算结果进行消费</h5><h6 id="thenRun、thenAccept、thenApply"><a href="#thenRun、thenAccept、thenApply" class="headerlink" title="(thenRun、thenAccept、thenApply)"></a><strong>(thenRun、thenAccept、thenApply)</strong></h6><p><strong><code>thenRun(Runnable action)</code></strong>:</p>
<ul>
<li>该方法在异步任务完成后执行指定的操作，不接收任务的结果。</li>
<li>它接受一个 <code>Runnable</code> 参数，表示要执行的操作。</li>
<li><code>thenRun()</code> 方法会等待当前任务完成后，执行指定的操作，无论前一个任务的结果是什么。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">            .thenRun(() -&gt; System.out.println(<span class="string">&quot;Task completed&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Task completed</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong><code>thenAccept(Consumer&lt;? super T&gt; action)</code></strong>:</p>
<ul>
<li>该方法在异步任务完成后对结果进行消费，不返回任何结果。</li>
<li>它接受一个 <code>Consumer</code> 参数，表示对结果进行消费的操作。</li>
<li><code>thenAccept()</code> 方法会等待当前任务完成后，将任务的结果作为参数传递给操作进行消费。</li>
</ul>
<p>通过传参可以看到，该方法是一个消费型接口，对传入数据进行消费，不返回结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">            .thenApply(s -&gt; s+ <span class="string">&quot; world&quot;</span>)</span><br><span class="line">            .thenAccept(s -&gt; System.out.println(<span class="string">&quot;Result: &quot;</span> + s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Result: Hello world</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><code>thenApply方法同上</code></p>
<h5 id="对计算结果进行合并"><a href="#对计算结果进行合并" class="headerlink" title="对计算结果进行合并"></a>对计算结果进行合并</h5><h6 id="thenCombine、thenAcceptBoth、runAfterBoth"><a href="#thenCombine、thenAcceptBoth、runAfterBoth" class="headerlink" title="(thenCombine、thenAcceptBoth、runAfterBoth)"></a><strong>(thenCombine、thenAcceptBoth、runAfterBoth)</strong></h6><p><strong><code>thenCombine(CompletableFuture&lt;? extends U&gt; other, BiFunction&lt;? super T, ? super U, ? extends V&gt; fn)</code></strong>:</p>
<ul>
<li>该方法用于组合两个异步任务的结果，并在两个任务都完成后执行指定的操作，并返回一个新的 <code>CompletableFuture</code> 对象。</li>
<li>它接受另一个 <code>CompletableFuture</code> 对象 <code>other</code> 和一个 <code>BiFunction</code> 参数，该函数接受两个任务的结果类型 <code>T</code> 和 <code>U</code>，并返回类型 <code>V</code>。</li>
<li><code>thenCombine()</code> 方法会等待当前任务和 <code>other</code> 任务都完成后，将两个任务的结果作为参数传递给函数，并返回一个新的 <code>CompletableFuture</code> 对象，表示对结果进行组合后的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="number">20</span>)</span><br><span class="line">                            .thenCombine(future1, (s1,s2) -&gt; s1*s2);</span><br><span class="line">    System.out.println(future2.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">200</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>



<p><strong><code>thenAcceptBoth(CompletableFuture&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action)</code></strong>:</p>
<ul>
<li>该方法用于在两个异步任务都完成后执行指定的操作，不返回任何结果。</li>
<li>它接受另一个 <code>CompletableFuture</code> 对象 <code>other</code> 和一个 <code>BiConsumer</code> 参数，该函数接受两个任务的结果类型 <code>T</code> 和 <code>U</code>，并执行指定的操作。</li>
<li><code>thenAcceptBoth()</code> 方法会等待当前任务和 <code>other</code> 任务都完成后，将两个任务的结果作为参数传递给操作进行消费。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="number">20</span>);</span><br><span class="line">    CompletableFuture&lt;Void&gt; combinedFuture = future1.</span><br><span class="line">            thenAcceptBoth(future2, (result1, result2) -&gt;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Combined result: &quot;</span> + (result1 + result2)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法与thenCombine类似，区别在于thenCombine有返回，而thenAcceptBoth无返回值</p>
<p>结果不言而喻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Combined result: <span class="number">30</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong><code>runAfterBoth(CompletableFuture&lt;?&gt; other, Runnable action)</code></strong>:</p>
<ul>
<li><p>该方法用于在两个异步任务都完成后执行指定的操作，不接收任务的结果。</p>
</li>
<li><p>它接受另一个 <code>CompletableFuture</code> 对象 <code>other</code> 和一个 <code>Runnable</code> 参数，表示要执行的操作。</p>
</li>
<li><p><code>runAfterBoth()</code> 方法会等待当前任务和 <code>other</code> 任务都完成后，执行指定的操作。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="number">20</span>);</span><br><span class="line">    CompletableFuture&lt;Void&gt; combinedFuture = future1.</span><br><span class="line">            runAfterBoth(future2, () -&gt; System.out.println(<span class="string">&quot;Both tasks completed&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相较于上面两个方法，runAfterBoth 又有些不同，他既不接收返回值，也不返回，而是等待两个future执行好了之后在去执行，所以一般用于在程序结束</p>
<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Both tasks completed</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h5 id="对计算速度进行选用"><a href="#对计算速度进行选用" class="headerlink" title="对计算速度进行选用"></a>对计算速度进行选用</h5><h6 id="applyToEither、acceptEither、runAfterEither"><a href="#applyToEither、acceptEither、runAfterEither" class="headerlink" title="(applyToEither、acceptEither、runAfterEither)"></a><strong>(applyToEither、acceptEither、runAfterEither)</strong></h6><p><strong><code>applyToEither(CompletableFuture&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn)</code></strong>:</p>
<ul>
<li>该方法接受另一个 <code>CompletableFuture</code> 对象 <code>other</code> 和一个 <code>Function</code> 参数，并返回一个新的 <code>CompletableFuture</code> 对象。</li>
<li><code>applyToEither()</code> 方法会等待当前任务和 <code>other</code> 任务中的任意一个完成，并将首先完成的任务的结果作为参数传递给函数进行转换。</li>
<li>返回的 <code>CompletableFuture</code> 对象的结果类型为 <code>U</code>，表示对首先完成任务的结果进行转换后的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; voidCompletableFuture = future1.applyToEither(future2, s -&gt; s * <span class="number">123</span>)</span><br><span class="line">            .thenApply(s -&gt; <span class="string">&quot;Result: &quot;</span> + s)</span><br><span class="line">            .thenAccept(res -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">                System.out.println(res);</span><br><span class="line">            &#125;);</span><br><span class="line">    voidCompletableFuture.join();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--------------------------</span><br><span class="line">Result: <span class="number">2460</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>很明显返回的是 <strong>future2 的20</strong></p>
<p><strong><code> acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</code></strong></p>
<p><code>acceptEither</code> 是 <code>CompletableFuture</code> 类中的一个方法，用于处理两个独立的异步任务，并且只接受其中一个操作的结果。可以这么理解：如果第一个异步任务完成了，则使用它的结果进行处理，否则使用第二个异步任务的结果</p>
<p>示例 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    future1.acceptEither(future2, System.out::println).join();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>runAfterEither方法签名</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title function_">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other, Runnable action)</span>;</span><br></pre></td></tr></table></figure>

<p><code>runAfterEither</code> 方法接收两个参数：一个是另一个 <code>CompletionStage</code> 对象，另一个是一个 <code>Runnable</code> 或者 <code>Consumer</code> 对象。当其中任意一个 <code>CompletionStage</code> 完成（无论是正常完成还是异常完成），就会执行指定的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 执行某个任务</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 执行另一个任务</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">future1.runAfterEither(future2, () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了操作&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们创建了两个 <code>CompletableFuture</code> 对象 <code>future1</code> 和 <code>future2</code>，分别代表两个异步任务。然后，我们调用 <code>runAfterEither</code> 方法，传递了这两个 <code>CompletableFuture</code> 对象和一个 <code>Runnable</code> 对象作为参数。当 <code>future1</code> 或者 <code>future2</code> 中的任意一个完成时，即可执行传入的操作，这里是简单地打印一条消息。</p>
<h5 id="多任务组合"><a href="#多任务组合" class="headerlink" title="多任务组合"></a>多任务组合</h5><p><strong><code>allOf(CompletableFuture&lt;?&gt;... futures)</code></strong>:</p>
<ul>
<li>该方法接受一个 <code>CompletableFuture</code> 数组作为参数，并返回一个新的 <code>CompletableFuture</code> 对象。</li>
<li><code>allOf()</code> 方法等待所有给定的任务都完成后，返回一个新的 <code>CompletableFuture</code> 对象。</li>
<li>返回的 <code>CompletableFuture</code> 对象的结果为 <code>Void</code>，表示所有任务都已完成。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Result 1&quot;</span>);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="number">42</span>);</span><br><span class="line">    CompletableFuture&lt;Boolean&gt; future3 = CompletableFuture.supplyAsync(() -&gt; <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(future1, future2, future3);</span><br><span class="line">    allFutures.thenRun(() -&gt; System.out.println(<span class="string">&quot;All tasks completed&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>allof方法使用类似于遍历一个CompletableFuture数组并执行，不同是的，他会等待所有结果出来后才会打印 thenRun()后得内容。而不返回任何内容。</p>
<p>结果不言而喻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">All tasks completed</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>



<p><strong><code>anyOf(CompletableFuture&lt;?&gt;... futures)</code></strong>:</p>
<ul>
<li>该方法接受一个 <code>CompletableFuture</code> 数组作为参数，并返回一个新的 <code>CompletableFuture</code> 对象。</li>
<li><code>anyOf()</code> 方法等待任何一个给定的任务完成后，返回一个新的 <code>CompletableFuture</code> 对象。</li>
<li>返回的 <code>CompletableFuture</code> 对象的结果为第一个完成的任务的结果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Result 1&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Boolean&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Object&gt; anyFuture = CompletableFuture.anyOf(future1, future2, future3);</span><br><span class="line">    System.out.println(anyFuture.join());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们创建了三个Completable对象，并一次加入一个新的CompletableFuture.anyof方法中，三个线程分别等待不同的时间，我们预计anyFuture接收第一个运行结束并返回得CompletableFuture对象</p>
<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">42</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized和lock</title>
    <url>/2023/05/29/synchronized%E5%92%8Clock/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="synchronized和lock"><a href="#synchronized和lock" class="headerlink" title="synchronized和lock"></a>synchronized和lock</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized关键字用于Java中同步方法或同步代码块中，防止资源冲突。当任务要执行被synchronized关键字保护的代码片段的时候，它将检查锁是否可用，然后获取锁，执行代码，释放锁。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">synchronizedMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 该方法的内容在同一时间只能被一个线程执行</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 非同步的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 被同步的代码块</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其余不在赘述，相关使用应该很常见</p>
<h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>除了使用synchronized外，我们可以使用Lock接口写的<code>ReentrantLock</code> 实现独占锁的功能。</p>
<p>查看类图可知，<code>ReentrantLock</code> 实现了Lock接口</p>
<p><img src="https://pic1.imgdb.cn/item/64741b67f024cca1738eebeb.png"></p>
<p>Lock接口定义了几个方法用来实现锁的基本功能</p>
<ul>
<li><code>lock() : void</code>    					       &#x2F;&#x2F;获得锁。</li>
<li><code>lockInterruptibly() : void</code>    &#x2F;&#x2F; 获取锁定，除非当前线程是 <a href="../../../../java/lang/Thread.html#interrupt--">interrupted</a> 。 </li>
<li><code>tryLock() : boolean</code>                   &#x2F;&#x2F;   只有在调用时才可以获得锁</li>
<li><code>tryLock(time : long,unit : TimeUnit ) : boolean</code>   &#x2F;&#x2F; 如果在给定的等待时间内是空闲的，并且当前的线程尚未得到 <a href="../../../../java/lang/Thread.html#interrupt--">interrupted，</a>则获取该锁。 </li>
<li><code>unlock() : void</code>                           &#x2F;&#x2F;  释放锁。</li>
<li><code>newCondition() : Condition</code>    &#x2F;&#x2F; 返回一个新<a href="../../../../java/util/concurrent/locks/Condition.html"><code>Condition</code></a>绑定到该实例<code>Lock</code>实例。</li>
</ul>
<p>常用方法应该是lock()&#x2F;unlock()和newCondition(),简要阐述一下，由ReentrantLock实现</p>
<h4 id="lock和unlock"><a href="#lock和unlock" class="headerlink" title="lock和unlock"></a>lock和unlock</h4><p>lock和unlock方法是Lock接口提供的重要的加锁解锁方法，他们包围的代码片段就是相应的加锁处理片段，下面是一个简单的示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockExample</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span>   <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;lock 测试&quot;</span>+ object.toString());</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要新建Lock对象后在需要锁的开始和结束处使用lock方法和unlock方法进行加锁和解锁就可以完成相应的功能。</p>
<p>需要注意，如果锁内部代码出现异常可能会造成lock对象的unlock方法没有执行，从而未释放锁。所以相应的功能应该卸载try catch代码块中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span>   <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lock 测试&quot;</span>+ object.toString());</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="newCondition"><a href="#newCondition" class="headerlink" title="newCondition"></a>newCondition</h4><p><code>newCondition</code>()方法是Lock接口中线程通讯的重要实现，他返回一个<code>Condition</code>对象，<code>Condition</code>类似于<code>Object</code>监视器方法（ <a href="../../../../java/lang/Object.html#wait--"><code>wait</code></a> ， <a href="../../../../java/lang/Object.html#notify--"><code>notify</code></a>和<a href="../../../../java/lang/Object.html#notifyAll--"><code>notifyAll</code></a>  ），将其中的重要方法封装成了不同的对象，以得到具有多个等待集的每个对象，通过将它们与使用任意的组合的效果<a href="../../../../java/util/concurrent/locks/Lock.html"><code>Lock</code>个</a>实现。  <code>Lock</code>替换<code>synchronized</code>方法和语句的使用，  <code>Condition</code>取代了对象监视器方法的使用。 下面是一个简单的示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个共享的计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个锁和条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个增加计数器的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(<span class="string">&quot;Counter value: &quot;</span> + count);</span><br><span class="line">            <span class="comment">// 通知其他线程，计数器已经增加</span></span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个减少计数器的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 等待其他线程通知，计数器已经增加</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(<span class="string">&quot;Counter value: &quot;</span> + count);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个线程，一个增加计数器，一个减少计数器</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                counter.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                counter.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待线程结束</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类定义了一个资源类和两个方法，一个增加计数，一个减少计数，循环5次，后通知另一线程执行，结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Counter value: <span class="number">1</span></span><br><span class="line">Counter value: <span class="number">2</span></span><br><span class="line">Counter value: <span class="number">3</span></span><br><span class="line">Counter value: <span class="number">4</span></span><br><span class="line">Counter value: <span class="number">5</span></span><br><span class="line">Counter value: <span class="number">4</span></span><br><span class="line">Counter value: <span class="number">3</span></span><br><span class="line">Counter value: <span class="number">2</span></span><br><span class="line">Counter value: <span class="number">1</span></span><br><span class="line">Counter value: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>condition的使用类似于Object方法中的wait和notify方法，不同的是Condition类可以提供多个条件，实现更细粒度的线程等待和通知</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiConditionExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">condition1Met</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">condition2Met</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">awaitCondition1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!condition1Met) &#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// condition1Met 为 true，执行相关操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Condition 1 开始运行&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">awaitCondition2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!condition2Met) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// condition2Met 为 true，执行相关操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Condition 2 met&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signalCondition1</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition1Met = <span class="literal">true</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signalCondition2</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition2Met = <span class="literal">true</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MultiConditionExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultiConditionExample</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                example.signalCondition1();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                example.signalCondition2();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                example.awaitCondition1();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                example.awaitCondition2();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">            thread3.join();</span><br><span class="line">            thread4.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Condition <span class="number">1</span> met</span><br><span class="line">Condition <span class="number">2</span> met</span><br></pre></td></tr></table></figure>

<p>这个示例只是将一对Condition信号复制了一份放在一个类中执行，不同于wait&#x2F;notify，Condition在这个可以根据实例信号（condition1&#x2F;condition2)来指定需要通讯的线程。</p>
<h2 id="Synchronized和Lock对比"><a href="#Synchronized和Lock对比" class="headerlink" title="Synchronized和Lock对比"></a>Synchronized和Lock对比</h2><ol>
<li><strong>获取方式</strong>：<ul>
<li><code>Synchronized</code>：通过 <code>synchronized</code> 关键字来实现，可以修饰方法或代码块。</li>
<li><code>Lock</code>：通过 <code>Lock</code> 接口的实现类（如 <code>ReentrantLock</code>）来创建实例，并调用其方法进行获取锁。</li>
</ul>
</li>
<li><strong>使用方式</strong>：<ul>
<li><code>Synchronized</code>：在方法上使用 <code>synchronized</code> 关键字或使用 <code>synchronized</code> 块来指定需要同步的代码块。</li>
<li><code>Lock</code>：使用 <code>Lock</code> 对象的 <code>lock()</code> 方法获取锁，然后使用 <code>unlock()</code> 方法释放锁。</li>
</ul>
</li>
<li><strong>灵活性</strong>：<ul>
<li><code>Synchronized</code>：是内置的、<strong>隐式</strong>的锁机制，具有<strong>自动释放锁</strong>的特性，可以很方便地使用，但相对较为简单，提供的功能相对有限。</li>
<li><code>Lock</code>：是<strong>显式</strong>的锁机制，提供了更多的灵活性和功能，例如可重入性、公平性、条件变量等，但需要手动管理锁的获取和释放。</li>
</ul>
</li>
<li><strong>性能</strong>：<ul>
<li><code>Synchronized</code>：在 Java 6 之后进行了很多优化，性能已经大幅提升，尤其在无竞争的情况下，性能表现良好。</li>
<li><code>Lock</code>：性能相对较好，并且在高度竞争的情况下能够提供更好的性能表现。</li>
</ul>
</li>
<li><strong>可中断性</strong>：<ul>
<li><code>Synchronized</code>：一旦获取到锁，无法被其他线程中断，只能等待锁的释放。</li>
<li><code>Lock</code>：提供了可中断的获取锁的方法 <code>lockInterruptibly()</code>，可以在等待锁的过程中响应中断。</li>
</ul>
</li>
<li><strong>条件变量</strong>：<ul>
<li><code>Synchronized</code>：不直接支持条件变量，但可以通过 <code>Object</code> 的 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 方法结合 <code>synchronized</code> 关键字来实现类似的功能。</li>
<li><code>Lock</code>：提供了 <code>Condition</code> 接口来支持条件变量，可以使用 <code>newCondition()</code> 方法创建条件对象，并使用其 <code>await()</code>、<code>signal()</code> 和 <code>signalAll()</code> 方法进行线程等待和通知。</li>
</ul>
</li>
</ol>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p>JDK官方文档：<a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html">Synchronized Methods (The Java™ Tutorials &gt; Essential Java Classes &gt; Concurrency) (oracle.com)</a></p>
<p><a href="https://www.cnblogs.com/cz123/p/7435113.html">synchronized VS Lock, wait-notify VS Condition</a></p>
<p>chatGPT3.5</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>pyqt5入门</title>
    <url>/2023/02/03/pyqt5%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="pythonGUI-pyqt5-入门"><a href="#pythonGUI-pyqt5-入门" class="headerlink" title="pythonGUI(pyqt5)入门"></a>pythonGUI(pyqt5)入门</h2><p><em>参考书籍《PyQt5快速开发与实战》王硕 孙洋洋 著</em></p>
<h5 id="为什么选择pyqt5"><a href="#为什么选择pyqt5" class="headerlink" title="为什么选择pyqt5"></a>为什么选择pyqt5</h5><p>诚然，对于python来说，有很多可选得gui库，比如python自带库Tkinter、wxPython、pyside2&#x2F;6、pyqt5&#x2F;6、甚至是pygame。pyqt是很成熟得第三方库，pyqt源于C++QT框架，功能十分强大，并且有qtdesigner可视化工具加持，大大简化开发得复杂度。pyside和pyqt均为qt框架下得python第三方库，选择pyqt5得主要原因是pyqt5有着更丰富得学习资源。</p>
<h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QMainWindow , QApplication </span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QIcon </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span>(<span class="title class_ inherited__">QMainWindow</span>): </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,parent=<span class="literal">None</span></span>): </span><br><span class="line">        <span class="built_in">super</span>(MainWindow,self).__init__(parent) </span><br><span class="line">        self.resize(<span class="number">400</span>, <span class="number">200</span>) </span><br><span class="line">        self.status = self.statusBar() </span><br><span class="line">        self.status.showMessage(<span class="string">&quot;这是状态栏提示&quot;</span>,<span class="number">5000</span>) <span class="comment">#底部状态栏，5s后消失</span></span><br><span class="line">        self.setWindowTitle(<span class="string">&quot;PyQt MainWindow 例子&quot;</span>) </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: </span><br><span class="line">     app = QApplication(sys.argv) </span><br><span class="line">     app.setWindowIcon(QIcon(<span class="string">&quot;./images/cartoon1.ico&quot;</span>)) <span class="comment">#设置图标</span></span><br><span class="line">     form = MainWindow() <span class="comment">#实例化mainwindow类</span></span><br><span class="line">     form.show() <span class="comment">#调用show方法，展示gui界面</span></span><br><span class="line">     sys.exit(app.exec_())  <span class="comment">#系统退出</span></span><br></pre></td></tr></table></figure>

<p>运行以上示例，会生成一个gui界面，右下角出现 “这是状态栏提示” 5s后消失</p>
<h3 id="Qtdesigner"><a href="#Qtdesigner" class="headerlink" title="Qtdesigner"></a>Qtdesigner</h3><p>Qt Designer 是专门用来制作 PyQt 程序中 UI 界 面的工具，它生成的 UI 界面是一个后缀为.ui 的文件。该文件使用起来非常简单， 可以通过命令将.ui 文件转换成.py 格式的文件。实际上就是将组件转化为python类对象，   </p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title>windows本地密码管理器</title>
    <url>/2023/03/20/windows%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="本地密码管理器4-0"><a href="#本地密码管理器4-0" class="headerlink" title="本地密码管理器4.0"></a>本地密码管理器4.0</h2><p><code>github</code>地址：<a href="https://github.com/nerkeler/account.git">https://github.com/nerkeler/account.git</a></p>
<p>蓝奏云：<a href="https://wwtf.lanzoul.com/b01ereqoh">https://wwtf.lanzoul.com/b01ereqoh</a> 密码:9920<br>文叔叔：<a href="https://t.wss.ink/f/b4jc2yer65e">https://t.wss.ink/f/b4jc2yer65e</a> </p>
<h4 id="重要提示"><a href="#重要提示" class="headerlink" title="重要提示"></a>重要提示</h4><p>程序默认密码：<strong>password</strong></p>
<p>密钥位置：<code>./resource/aesKey   </code>     建议另存一份以作备份</p>
<h4 id="修改点"><a href="#修改点" class="headerlink" title="修改点"></a>修改点</h4><ul>
<li>本地密码导出中文乱码修复</li>
<li>引入日志记录</li>
<li>优化edge&#x2F;chrome 浏览器导出适配管理</li>
</ul>
<p><em>PS: 程序第一次打开关于页面显示不完整，如果遇到，请关闭后再打开</em></p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>闲来无事，看到自己有很多网站的账户密码，有些网站可能打开一两次也就忘记了，下一次在输入账户密码就想不起来，这样很容易丢失账号（当然也可以保存在浏览器自带的密码管理器中），虽然市面上也有很多优秀的账户密码管理软件，一来是这些程序大都是联网运行，在提供了多端存档的同时，也将密码和账户在网络上传输，虽然实际上很安全，但是并不是绝对的安全，二来，部分优秀的程序都是订阅付费机制，就想着自己干脆写个简单的本地的账户管理器，于是就有了这个小程序</p>
<p>先说一下优点吧，同市面上的程序比较，一个最突出的优点就是完全运行在本地，账户密码经过<code>AES</code>加密，在逻辑上可以说是非常安全的，因为你的密码不会暴漏在网络上，本地也进行了加密处理。</p>
<p>当然缺点也很明显，一是功能不是十分完善，二是该程序使用<code>tkinter</code> 模块编写，在布局和界面展示上都显得十分简陋，好在基本的功能没有问题</p>
<h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><ol>
<li>下载解压程序文件</li>
<li>运行<code>account.exe</code>文件</li>
<li>点击<code>新建账号</code>按钮添加新的账号密码信息</li>
<li>双击表格中的数据进行编辑或删除</li>
<li>点击<code>导出</code>按钮验证密钥密码后将数据导出为CSV格式文件</li>
<li>点击<code>导入</code>按钮选择CSV文件进行导入数据</li>
<li>可按需求导入并管理<code>Chrome/Edge密码本</code>浏览器密码</li>
</ol>
<h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p><img src="https://pic.imgdb.cn/item/6415d3c2a682492fcc12ae16.png"></p>
<p>第一次登陆密钥弹出框被关闭时，就进入了程序的登录界面，默认账户名admin 不可修改，默认密码为 ：**<code>password</code>**，建议第一次登陆时修改密码</p>
<p><em><strong>PS: 多用户功能尚未开发，因此账户名锁定不可编辑</strong></em></p>
<h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><img src="https://pic.imgdb.cn/item/642fd3b4a682492fcc59f817.png"></p>
<p>在登陆界面 点击   <strong>改密</strong>  进入修改密码界面，新密码要求字符数大于8位，点击<strong>确定</strong> 按钮即可进行密码修改，修改成功后会提示修改成功，重新登陆，如下图所示</p>
<p><img src="https://pic.imgdb.cn/item/6415d527a682492fcc1573f4.png"></p>
<h4 id="chrome-x2F-edge浏览器密码导入管理"><a href="#chrome-x2F-edge浏览器密码导入管理" class="headerlink" title="chrome&#x2F;edge浏览器密码导入管理"></a>chrome&#x2F;edge浏览器密码导入管理</h4><p>依次点击：</p>
<ol>
<li><p>设置</p>
</li>
<li><p>自动填充</p>
</li>
<li><p>密码管理器</p>
<p><strong>找到如图红框内容，验证设备密码后导出chrome密码本csv文件到本地</strong></p>
<p><img src="https://pic2.imgdb.cn/item/645366670d2dde5777904d8e.png"></p>
</li>
</ol>
<p>回到程序后点击导入</p>
<p>对应导入源后选择导入文件即可导入数据，<strong>单线程导入较慢，请耐心等待</strong>，快捷键暂未适配</p>
<p><img src="https://pic2.imgdb.cn/item/645366ec0d2dde5777911e80.png"></p>
<h4 id="主页面"><a href="#主页面" class="headerlink" title="主页面"></a>主页面</h4><p>主界面略作修改</p>
<p><img src="https://pic2.imgdb.cn/item/645365530d2dde57778ec79f.png"></p>
<p>主界面共分为两个区域：</p>
<ul>
<li>一个是上方的功能区，提供了查询、查看、新增、删除（软删除）功能，</li>
<li>一个是下方的账户展示区域，默认打开时按照列表展示所有账户信息</li>
</ul>
<h5 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h5><ul>
<li><p>下拉框提供了  账户编号（对应下方序号列）、网站名称（对应下方网站列）、网站网址（对应下方网址列）查询条件转换</p>
</li>
<li><p>文本框接受  下拉框的对应字段，<strong>为空时默认查询所有</strong></p>
</li>
<li><p>点击某一项账户时，<strong>点击查看&#x2F;双击当前项</strong>  可进入当前账户查看界面，如图所示，当前页面也可以更新账户信息</p>
</li>
<li><p>新增按钮会弹出新增界面，按照规定指示填写字段即可新增一条记录</p>
</li>
<li><p>删除按钮  在点击某一项账户时，点击删除，即可删除当前记录（软删除，更改了当前的状态）</p>
</li>
</ul>
<h4 id="随机密码"><a href="#随机密码" class="headerlink" title="随机密码"></a>随机密码</h4><p>可以按照自己的需求生成相应的密码规则，<code>ABC</code>&#x2F;<code>123</code>&#x2F;<code>abc</code>&#x2F;<code>#$&amp;</code></p>
<p><em>注：在密码长度&gt;字符类型数的时候会补数字  如  密码长度选30  规则选<code>abc</code>  会在26个字符后再补几个数字构成随机字符</em></p>
<p><img src="https://pic.imgdb.cn/item/6424f580a682492fcc9f685c.png"></p>
<h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><p>聊胜于无，简单说一下，详细见程序页面</p>
<h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p>忘记登陆账户密码时，可将<code>account.db</code> 文件使用数据库可视化工具打开，取出当前账户的相关信息和密码，根据密钥和加密逻辑解密当前账户的密码明文</p>
<p>加密逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_password</span>(<span class="params">password</span>):</span><br><span class="line">	key = yourkey			<span class="comment"># key 表示你的密钥 </span></span><br><span class="line">    </span><br><span class="line">	slot = <span class="string">&quot;nerkeler&quot;</span></span><br><span class="line">    encode = key + slot</span><br><span class="line">    myKey = hashlib.md5(encode.encode(<span class="string">&quot;utf-8&quot;</span>)).hexdigest().__str__()[:<span class="number">24</span>]</span><br><span class="line">    <span class="keyword">return</span> aes_encode(myKey, password)</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_decode</span>(<span class="params">key, ciphertext</span>):</span><br><span class="line">    <span class="comment"># 将密钥填充到16的倍数</span></span><br><span class="line">    key = key + (<span class="number">16</span> - <span class="built_in">len</span>(key) % <span class="number">16</span>) * <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">    <span class="comment"># 创建AES密码器对象</span></span><br><span class="line">    cipher = AES.new(key.encode(), AES.MODE_ECB)</span><br><span class="line">    <span class="comment"># 解码Base64编码的密文</span></span><br><span class="line">    ciphertext = base64.b64decode(ciphertext)</span><br><span class="line">    <span class="comment"># 解密</span></span><br><span class="line">    plaintext = cipher.decrypt(ciphertext)</span><br><span class="line">    <span class="comment"># 去除填充字符</span></span><br><span class="line">    plaintext = plaintext.rstrip(<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> plaintext.decode()</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>后期打算使用<code>pyside6</code>重写一版，<code>Tkinter</code>版本不准备大改动了，如果有使用建议和bug,欢迎打扰，详见关于页</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title>Python日志模块logging的使用详解</title>
    <url>/2023/05/04/ython%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97logging%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python日志模块logging的使用详解"><a href="#Python日志模块logging的使用详解" class="headerlink" title="Python日志模块logging的使用详解"></a>Python日志模块logging的使用详解</h1><p><em><strong>PS: 转载自  <a href="https://github.com/HuiDBK/LogSetupDemo">https://github.com/HuiDBK/LogSetupDemo</a></strong></em></p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><blockquote>
<p>在开发一些大型项目的时候，都会使用日志来记录项目运行时产生的信息，以备出错时定位分析和从日志信息中提取数据统计分析等。在 <code>Python</code> 中使用 <code>logging</code> 内置模块即可对项目进行日志的配置。</p>
</blockquote>
<h2 id="logging模块的使用"><a href="#logging模块的使用" class="headerlink" title="logging模块的使用"></a>logging模块的使用</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><blockquote>
<p><code>logging</code> 模块提供了一系列便利的函数</p>
<p>它们分别是 <code>debug(), info(), warning(), error(), critical()</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">&#x27;debug log test&#x27;</span>)</span><br><span class="line">logging.info(<span class="string">&#x27;info log test&#x27;</span>)</span><br><span class="line">logging.warning(<span class="string">&#x27;warning log test&#x27;</span>)</span><br><span class="line">logging.error(<span class="string">&#x27;error log test&#x27;</span>)</span><br><span class="line">logging.critical(<span class="string">&#x27;critical log test&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p><strong>输出结果：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">WARNING:root:warning log test</span><br><span class="line">ERROR:root:error log test</span><br><span class="line">CRITICAL:root:critical log test</span><br></pre></td></tr></table></figure>

<p>为什么只输出了 <code>warning</code>， <code>error</code> 和 <code>critical</code> 的结果，因为 <code>logging</code> 模块默认使用 <code>warning</code> 日志级别，就是只有 <code>warning</code> 及以上日志等级才会显示。</p>
<p>日志等级从高到低，如下所示</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>数值</th>
<th>何时使用</th>
</tr>
</thead>
<tbody><tr>
<td><code>CRITICAL</code></td>
<td>50</td>
<td>严重的错误，表明程序已不能继续执行</td>
</tr>
<tr>
<td><code>ERROR</code></td>
<td>40</td>
<td>由于严重的问题，程序的某些功能已经不能正常执行</td>
</tr>
<tr>
<td><code>WARNING</code></td>
<td>30</td>
<td>表明有已经或即将发生的意外，程序仍按预期进行</td>
</tr>
<tr>
<td><code>INFO</code></td>
<td>20</td>
<td>确认程序按预期运行</td>
</tr>
<tr>
<td><code>DEBUG</code></td>
<td>10</td>
<td>细节信息，仅当诊断问题时适用。</td>
</tr>
<tr>
<td><code>NOTSET</code></td>
<td>0</td>
<td>无任何等级限制</td>
</tr>
</tbody></table>
<p>我们只要把 <code>logging</code> 的默认日志等级改下就好了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置日志等级</span></span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">&#x27;debug log test&#x27;</span>)</span><br><span class="line">logging.info(<span class="string">&#x27;info log test&#x27;</span>)</span><br><span class="line">logging.warning(<span class="string">&#x27;warning log test&#x27;</span>)</span><br><span class="line">logging.error(<span class="string">&#x27;error log test&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p><strong>输出结果如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DEBUG:root:debug log test</span><br><span class="line">INFO:root:info log test</span><br><span class="line">WARNING:root:warning log test</span><br><span class="line">ERROR:root:error log test</span><br></pre></td></tr></table></figure>



<h3 id="指定日志输出样式"><a href="#指定日志输出样式" class="headerlink" title="指定日志输出样式"></a>指定日志输出样式</h3><p>当然我们还可以指定日志输出格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志输出样式</span></span><br><span class="line">log_format = <span class="string">&#x27;%(levelname)s %(asctime)s %(filename)s %(lineno)d %(message)s&#x27;</span></span><br><span class="line">logging.basicConfig(<span class="built_in">format</span>=log_format, level=logging.DEBUG)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">&#x27;debug log test&#x27;</span>)</span><br><span class="line">logging.info(<span class="string">&#x27;info log test&#x27;</span>)</span><br><span class="line">logging.warning(<span class="string">&#x27;warning log test&#x27;</span>)</span><br><span class="line">logging.error(<span class="string">&#x27;error log test&#x27;</span>)</span><br><span class="line">logging.critical(<span class="string">&#x27;critical log test&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p><strong>输出结果如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DEBUG <span class="number">2021</span>-05-<span class="number">27</span> <span class="number">00</span>:04:<span class="number">26</span>,<span class="number">327</span> main.py <span class="number">65</span> debug log test</span><br><span class="line">INFO <span class="number">2021</span>-05-<span class="number">27</span> <span class="number">00</span>:04:<span class="number">26</span>,<span class="number">327</span> main.py <span class="number">66</span> info log test</span><br><span class="line">WARNING <span class="number">2021</span>-05-<span class="number">27</span> <span class="number">00</span>:04:<span class="number">26</span>,<span class="number">327</span> main.py <span class="number">67</span> warning log test</span><br><span class="line">ERROR <span class="number">2021</span>-05-<span class="number">27</span> <span class="number">00</span>:04:<span class="number">26</span>,<span class="number">327</span> main.py <span class="number">68</span> error log test</span><br><span class="line">CRITICAL <span class="number">2021</span>-05-<span class="number">27</span> <span class="number">00</span>:04:<span class="number">26</span>,<span class="number">327</span> main.py <span class="number">69</span> critical log test</span><br></pre></td></tr></table></figure>



<p>其中日志信息格式化输出配置样式说明</p>
<ul>
<li><strong>%(levelname)s ，日志等级</strong></li>
<li><strong>%(asctime)s ，时间</strong></li>
<li><strong>%(filename)s ，文件名</strong></li>
<li><strong>%(lineno)d ，行号</strong></li>
<li><strong>%(message)s，日志信息</strong></li>
</ul>
<p>这些配置都是固定，不可随便写，还有好多日志格式化样式，这里只介绍了一些常用的格式配置，大家可以去官网查看更多的格式化配置信息。<a href="https://docs.python.org/zh-cn/3.7/library/logging.html#formatter-objects">https://docs.python.org/zh-cn/3.7/library/logging.html#formatter-objects</a></p>
<h3 id="日志记录到文件中"><a href="#日志记录到文件中" class="headerlink" title="日志记录到文件中"></a>日志记录到文件中</h3><p>在 <code>logging.basicConfig</code> 中设置 <code>filename</code> 属性即可把日志信息写入文件中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志输出样式</span></span><br><span class="line">log_format = <span class="string">&#x27;%(levelname)s %(asctime)s %(filename)s %(lineno)d %(message)s&#x27;</span></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    filename=<span class="string">&#x27;test.log&#x27;</span>,</span><br><span class="line">    <span class="built_in">format</span>=log_format,</span><br><span class="line">    level=logging.DEBUG</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">logging.debug(<span class="string">&#x27;debug log test&#x27;</span>)</span><br><span class="line">logging.info(<span class="string">&#x27;info log test&#x27;</span>)</span><br><span class="line">logging.warning(<span class="string">&#x27;warning log test&#x27;</span>)</span><br><span class="line">logging.error(<span class="string">&#x27;error log test&#x27;</span>)</span><br><span class="line">logging.critical(<span class="string">&#x27;critical log test&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>运行程序后 <code>test.log</code> 如下内容</p>
<p><a href="https://camo.githubusercontent.com/0ec87edd65f7f606755fb53dce5758bfc8d623f6b913cba1e9f13d244c4530c5/68747470733a2f2f70312d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f38646262323366363033336434653565626134363138666232313033643264667e74706c762d6b3375316662706663702d77617465726d61726b2e696d616765"><img src="https://camo.githubusercontent.com/0ec87edd65f7f606755fb53dce5758bfc8d623f6b913cba1e9f13d244c4530c5/68747470733a2f2f70312d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f38646262323366363033336434653565626134363138666232313033643264667e74706c762d6b3375316662706663702d77617465726d61726b2e696d616765" alt="日志信息展示"></a></p>
<h2 id="自定义日志配置"><a href="#自定义日志配置" class="headerlink" title="自定义日志配置"></a>自定义日志配置</h2><blockquote>
<p>通常我们在项目中都是自定义一些通用日志配置，然后供项目全局使用。写好这些配置下次要在别的项目使用之间复制粘贴过来修改修改一下即可。来康康是如何配置的。</p>
</blockquote>
<h3 id="准备日志配置信息"><a href="#准备日志配置信息" class="headerlink" title="准备日志配置信息"></a>准备日志配置信息</h3><p>配置日志详细信息，需要导入 <code>logging.config</code> 来进行加载日志配置信息</p>
<p>首先准备日志配置信息字典</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">log_dict</span> <span class="string">=</span> &#123;</span><br><span class="line">    <span class="attr">&#x27;version&#x27;:</span> <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&#x27;disable_existing_loggers&#x27;:</span> <span class="literal">False</span>,  <span class="comment"># 是否禁用已经存在的日志器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 日志信息格式化输出配置</span></span><br><span class="line">    <span class="attr">&#x27;formatters&#x27;:</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 简单的日志输出</span></span><br><span class="line">        <span class="attr">&#x27;simple&#x27;:</span> &#123;</span><br><span class="line">            <span class="attr">&#x27;format&#x27;:</span> <span class="string">&#x27;%(levelname)s %(module)s %(lineno)d %(message)s&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 详细的日志输出</span></span><br><span class="line">        <span class="attr">&#x27;verbose&#x27;:</span> &#123;</span><br><span class="line">            <span class="attr">&#x27;format&#x27;:</span> <span class="string">&#x27;%(levelname)s %(asctime)s %(filename)s %(lineno)d %(message)s&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 日志信息处理器配置</span></span><br><span class="line">    <span class="attr">&#x27;handlers&#x27;:</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 向终端中输出日志</span></span><br><span class="line">        <span class="attr">&#x27;console&#x27;:</span> &#123;</span><br><span class="line">            <span class="attr">&#x27;level&#x27;:</span> <span class="string">&#x27;DEBUG&#x27;</span>,                   <span class="comment"># 处理的日志等级，DEBUG及以上</span></span><br><span class="line">            <span class="attr">&#x27;class&#x27;:</span> <span class="string">&#x27;logging.StreamHandler&#x27;</span>,   <span class="comment"># 日志处理器</span></span><br><span class="line">            <span class="attr">&#x27;formatter&#x27;:</span> <span class="string">&#x27;simple&#x27;</span>               <span class="comment"># 日志格式化配置</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 向文件中输出日志</span></span><br><span class="line">        <span class="attr">&#x27;file&#x27;:</span> &#123;</span><br><span class="line">            <span class="attr">&#x27;level&#x27;:</span> <span class="string">&#x27;INFO&#x27;</span>,                                    <span class="comment"># 处理的日志等级，DEBUG及以上</span></span><br><span class="line">            <span class="attr">&#x27;class&#x27;:</span> <span class="string">&#x27;logging.handlers.RotatingFileHandler&#x27;</span>,    <span class="comment"># 使用文件日志处理器</span></span><br><span class="line">            <span class="attr">&#x27;formatter&#x27;:</span> <span class="string">&#x27;verbose&#x27;</span>,                             <span class="comment"># 日志格式化配置</span></span><br><span class="line">            <span class="attr">&#x27;filename&#x27;:</span> <span class="string">&#x27;./logs/test.log&#x27;</span>,                      <span class="comment"># 日志文件存储位置</span></span><br><span class="line">            <span class="attr">&#x27;maxBytes&#x27;:</span> <span class="number">1024</span> <span class="string">*</span> <span class="number">1024</span>,        <span class="comment"># 每个日志文件最大 10MB, 单位: byte</span></span><br><span class="line">            <span class="attr">&#x27;backupCount&#x27;:</span> <span class="number">20</span>,              <span class="comment"># 如果文件满了, 自动扩充, 最多保留 20 个日志文件</span></span><br><span class="line">            <span class="attr">&#x27;encoding&#x27;:</span> <span class="string">&#x27;utf8&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认根日志器</span></span><br><span class="line">    <span class="attr">&#x27;root&#x27;:</span> &#123;</span><br><span class="line">        <span class="attr">&#x27;level&#x27;:</span> <span class="string">&#x27;DEBUG&#x27;</span>,           <span class="comment"># 允许接受的日志等级</span></span><br><span class="line">        <span class="attr">&#x27;handlers&#x27;:</span> [<span class="string">&#x27;console&#x27;</span>]     <span class="comment"># 选择日志处理器</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自定义的日志器</span></span><br><span class="line">    <span class="attr">&#x27;loggers&#x27;:</span> &#123;</span><br><span class="line">        <span class="attr">&#x27;server&#x27;:</span> &#123;</span><br><span class="line">            <span class="attr">&#x27;level&#x27;:</span> <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="attr">&#x27;handlers&#x27;:</span> [<span class="string">&#x27;file&#x27;</span>],</span><br><span class="line">            <span class="attr">&#x27;propagate&#x27;:</span> <span class="literal">True</span>       <span class="comment"># 设为 False则禁止将日志消息传递给父级记录器的处理程序中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中大字典的 <code>key</code> 都是固定，例如 <code>version,formatters, handlers, root, loggers</code>等都是固定的配置项。而有一些子选项是可以自己自定义如</p>
<ul>
<li><code>formatters</code> 下的 <code>simple</code> 和 <code>verbose</code>，是可以改成自己想要的名字。</li>
<li><code>handlers</code> 下的 <code>console</code> 和 <code>file</code> 也是可以修改的。</li>
<li><code>loggers</code> 下的 <code>server</code> 都是一样可以修改的</li>
</ul>
<p>具体配置的说明，在这字典中都有一一注释我就不全介绍了，我就介绍一下 <code>handlers</code> 日志处理器的配置</p>
<p>在 <code>logging</code> 模块中有许多 <strong>日志处理器类</strong>，我们只需要在 <code>pycharm</code> 中输入 <code>logging.Handler</code> 就能弹出最基本的几个日志处理类。</p>
<p><a href="https://camo.githubusercontent.com/18888f035e50185a528db0d5c84d423b56415cea1c014f4fe73cc81834a07b5a/68747470733a2f2f70362d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f65306632643238303531316434363965616663636563663564643934363531317e74706c762d6b3375316662706663702d77617465726d61726b2e696d616765"><img src="https://camo.githubusercontent.com/18888f035e50185a528db0d5c84d423b56415cea1c014f4fe73cc81834a07b5a/68747470733a2f2f70362d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f65306632643238303531316434363965616663636563663564643934363531317e74706c762d6b3375316662706663702d77617465726d61726b2e696d616765" alt="日志处理器"></a></p>
<p>而上文所用到的 <code>StreamHandler</code> 则是流处理器，日志将随着系统标准输入、输出流展示，而我们的 <strong>PyCharm终端、控制台等</strong> 显示的信息就属于系统标准输出流。</p>
<p>而 <code>RotatingFileHandler</code> 日志处理器则是 <code>FileHandler</code> 的子类。其主要作用就是把日志写入文件中，当文件内容达到最大限制时可以自动扩充日志文件，以达到日志文件的轮换。</p>
<h3 id="加载日志配置信息"><a href="#加载日志配置信息" class="headerlink" title="加载日志配置信息"></a>加载日志配置信息</h3><p>然后使用 <code>logging.config.dictConfig()</code> 方法加载日志配置，该方法接受一个 <strong>字典</strong> 参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author: Hui</span></span><br><span class="line"><span class="comment"># @Desc: &#123; 日志模块logging的使用 &#125;</span></span><br><span class="line"><span class="comment"># @Date: 2021/05/26 23:14</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line"></span><br><span class="line">log_dict = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,  <span class="comment"># 是否禁用已经存在的日志器</span></span><br><span class="line"></span><br><span class="line">    ...与上文一致故省略</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 默认根日志器</span></span><br><span class="line">    <span class="string">&#x27;root&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,  <span class="comment"># 接受的日志等级</span></span><br><span class="line">        <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;console&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 自定义的日志器</span></span><br><span class="line">    <span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;server&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;file&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>       <span class="comment"># 设为 False则禁止将日志消息传递给父级记录器的处理程序中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setup_logging</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    配置日志信息</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logging.config.dictConfig(config=log_dict)</span><br><span class="line">    logger = logging.getLogger()</span><br><span class="line">	<span class="comment"># logger = logging.getLogger(&#x27;root&#x27;)</span></span><br><span class="line">    </span><br><span class="line">    logger.debug(<span class="string">&#x27;debug log test&#x27;</span>)</span><br><span class="line">    logger.info(<span class="string">&#x27;info log test&#x27;</span>)</span><br><span class="line">    logger.warning(<span class="string">&#x27;warning log test&#x27;</span>)</span><br><span class="line">    logger.error(<span class="string">&#x27;error log test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    setup_logging()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>



<p>使用 <code>logging.getLogger()</code> 即可获取相应配置日志器，其接受一个日志器的名字，不传则默认使用 <code>root</code> 根日志器，同 <code>logging.getLogger(&#39;root&#39;)</code> 效果一致。</p>
<p>如果之间运行程序会出现如下错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ValueError: Unable to configure handler &#x27;file&#x27;</span><br></pre></td></tr></table></figure>

<p>那是因为你在日志配置中设置了一个文件处理器 <code>file</code> ，其日志文件将存储在 <code>filename</code> 配置项中，在这里是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./logs/test.log		# 代表存储在当前路径下的 logs目录下的 test.log 文件</span><br></pre></td></tr></table></figure>

<p><code>logging</code> 模块不会自动帮我们创建目录，因此只需在当前目录中创建一个 <code>logs</code> 目录即可。</p>
<p><strong>最后程序运行结果如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DEBUG main <span class="number">74</span> debug log test</span><br><span class="line">INFO main <span class="number">75</span> info log test</span><br><span class="line">WARNING main <span class="number">76</span> warning log test</span><br><span class="line">ERROR main <span class="number">77</span> error log test</span><br></pre></td></tr></table></figure>



<p>不用跟 <code>root</code> 根日志器，使用 <code>server</code> 日志器，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line"></span><br><span class="line">log_dict = &#123;...同上文省略...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setup_logging</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    配置日志信息</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logging.config.dictConfig(config=log_dict)</span><br><span class="line">    <span class="comment"># logger = logging.getLogger()</span></span><br><span class="line"></span><br><span class="line">    logger = logging.getLogger(<span class="string">&#x27;server&#x27;</span>)</span><br><span class="line">    logger.debug(<span class="string">&#x27;debug log test&#x27;</span>)</span><br><span class="line">    logger.info(<span class="string">&#x27;info log test&#x27;</span>)</span><br><span class="line">    logger.warning(<span class="string">&#x27;warning log test&#x27;</span>)</span><br><span class="line">    logger.error(<span class="string">&#x27;error log test&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    setup_logging()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()    </span><br></pre></td></tr></table></figure>



<p><strong>运行结果如下：</strong></p>
<p>控制台</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DEBUG main <span class="number">75</span> debug log test</span><br><span class="line">INFO main <span class="number">76</span> info log test</span><br><span class="line">WARNING main <span class="number">77</span> warning log test</span><br><span class="line">ERROR main <span class="number">78</span> error log test</span><br></pre></td></tr></table></figure>



<p>日志文件 <code>logs/test.log</code></p>
<p><a href="https://camo.githubusercontent.com/95cd1e913e93ec90f1d6666131732faed0d27008fc37f04e070b5c2bb074e98b/68747470733a2f2f70362d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f39663435353663633439633734353664623264373438363765626262393238657e74706c762d6b3375316662706663702d77617465726d61726b2e696d616765"><img src="https://camo.githubusercontent.com/95cd1e913e93ec90f1d6666131732faed0d27008fc37f04e070b5c2bb074e98b/68747470733a2f2f70362d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f39663435353663633439633734353664623264373438363765626262393238657e74706c762d6b3375316662706663702d77617465726d61726b2e696d616765" alt="文件日志信息"></a></p>
<p>由于 <code>server</code> 日志器设置了 <code>&#39;propagate&#39;: True</code>，会 将日志消息传递给父级记录器的处理程序中，因此不仅控制台会显示日志信息，文件也会记录，但文件记录的等级被设置成 <code>INFO</code> 了，因此 <code>DEBUG</code> 调试日志信息，将不会出现在文件中。</p>
<h2 id="使用日志配置文件"><a href="#使用日志配置文件" class="headerlink" title="使用日志配置文件"></a>使用日志配置文件</h2><blockquote>
<p>这里我将采用 <code>yaml</code> 格式的日志配置文件。具体配置内容和上文大致一样，多了一个 <code>error_file_handler</code> 错误日志处理器，目的就是把 <strong>错误日志单独放在一个文件中，方便以后排查错误</strong>。</p>
</blockquote>
<h3 id="创建日志配置文件"><a href="#创建日志配置文件" class="headerlink" title="创建日志配置文件"></a>创建日志配置文件</h3><p>创建 <code>logging.yaml</code> 文件，内容如下所示</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">disable_existing_loggers:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志信息格式化输出配置</span></span><br><span class="line"><span class="attr">formatters:</span></span><br><span class="line">    <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">&#x27;%(levelname)s %(filename)s %(lineno)d %(message)s&#x27;</span></span><br><span class="line">    <span class="attr">verbose:</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">&#x27;%(levelname)s %(asctime)s -Loc %(filename)s -Row %(lineno)d -%(name)s %(message)s&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志信息处理器配置</span></span><br><span class="line"><span class="attr">handlers:</span></span><br><span class="line">    <span class="attr">console:</span></span><br><span class="line">        <span class="attr">class:</span> <span class="string">logging.StreamHandler</span></span><br><span class="line">        <span class="attr">level:</span> <span class="string">DEBUG</span></span><br><span class="line">        <span class="attr">formatter:</span> <span class="string">simple</span></span><br><span class="line">        <span class="attr">stream:</span> <span class="string">ext://sys.stdout</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 错误日志单独处理</span></span><br><span class="line">    <span class="attr">error_file_handler:</span></span><br><span class="line">        <span class="attr">class:</span> <span class="string">logging.handlers.RotatingFileHandler</span></span><br><span class="line">        <span class="attr">level:</span> <span class="string">ERROR</span></span><br><span class="line">        <span class="attr">formatter:</span> <span class="string">verbose</span></span><br><span class="line">        <span class="attr">filename:</span> <span class="string">./logs/errors.log</span>   <span class="comment"># 错误日志文件存储位置</span></span><br><span class="line">        <span class="attr">maxBytes:</span> <span class="number">10485760</span>            <span class="comment"># 每个日志文件最大 10MB</span></span><br><span class="line">        <span class="attr">backupCount:</span> <span class="number">20</span>               <span class="comment"># 如果文件满了, 自动扩充, 最多保留 20 个日志文件</span></span><br><span class="line">        <span class="attr">encoding:</span> <span class="string">utf8</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">server_file_handler:</span></span><br><span class="line">      <span class="attr">class:</span> <span class="string">logging.handlers.RotatingFileHandler</span></span><br><span class="line">      <span class="attr">level:</span> <span class="string">INFO</span>                     <span class="comment"># 只在文件中记录INFO级别及以上的log</span></span><br><span class="line">      <span class="attr">formatter:</span> <span class="string">verbose</span></span><br><span class="line">      <span class="attr">filename:</span> <span class="string">./logs/server.log</span>    <span class="comment"># 项目日志文件, 记录所有日志信息</span></span><br><span class="line">      <span class="attr">maxBytes:</span> <span class="number">10485760</span>             <span class="comment"># 10MB</span></span><br><span class="line">      <span class="attr">backupCount:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">encoding:</span> <span class="string">utf8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根日志器</span></span><br><span class="line"><span class="attr">root:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">DEBUG</span></span><br><span class="line">    <span class="attr">handlers:</span> [<span class="string">console</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志器</span></span><br><span class="line"><span class="attr">loggers:</span></span><br><span class="line">    <span class="attr">server:</span></span><br><span class="line">        <span class="attr">level:</span> <span class="string">DEBUG</span>      <span class="comment"># 允许打印 DEBUG 及以上log</span></span><br><span class="line">        <span class="attr">handlers:</span> [<span class="string">server_file_handler</span>, <span class="string">error_file_handler</span>]</span><br><span class="line">        <span class="attr">propagate:</span> <span class="literal">True</span>   <span class="comment"># 设为 False则禁止将日志消息传递给父级记录器的处理程序中</span></span><br></pre></td></tr></table></figure>

<h3 id="加载日志配置函数"><a href="#加载日志配置函数" class="headerlink" title="加载日志配置函数"></a>加载日志配置函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># log_test.py 文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> coloredlogs</span><br><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目根路径</span></span><br><span class="line">BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志配置文件</span></span><br><span class="line">LOG_CONF_FILE = os.path.join(BASE_DIR, <span class="string">&#x27;logging.yaml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setup_logging</span>(<span class="params">default_path=LOG_CONF_FILE, default_level=logging.DEBUG, env_key=<span class="string">&#x27;LOG_CFG&#x27;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    配置项目日志信息</span></span><br><span class="line"><span class="string">    :param default_path: 日志文件默认路径</span></span><br><span class="line"><span class="string">    :param default_level: 日志默认等级</span></span><br><span class="line"><span class="string">    :param env_key: 系统环境变量名</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    path = default_path</span><br><span class="line"></span><br><span class="line">    value = os.getenv(env_key, <span class="literal">None</span>)  <span class="comment"># 获取对应的环境变量值</span></span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        path = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(path):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(path, mode=<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                logging_yaml = yaml.safe_load(f.read())</span><br><span class="line">                logging.config.dictConfig(logging_yaml)</span><br><span class="line">                coloredlogs.install(level=<span class="string">&#x27;DEBUG&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(e)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;无法加载日志配置文件, 请检查日志目录是否创建, 使用默认的日志配置&#x27;</span>)</span><br><span class="line">                logging.basicConfig(level=default_level)</span><br><span class="line">                coloredlogs.install(level=default_level)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logging.basicConfig(level=default_level)</span><br><span class="line">        coloredlogs.install(level=default_level)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;日志配置文件不存在, 使用默认的日志配置&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>这里使用到第三方库如下</p>
<ul>
<li><code>yaml</code> 是用于读取 <code>yaml</code> 格式的日志配置文件</li>
<li><code>coloredlogs</code> 用于让日志在控制台中有颜色显示。</li>
</ul>
<p>然后我们在项目中只要执行完 <code>setup_logging()</code> 日志配置函数</p>
<p>其他模块直接使用 <code>logging.getLogger(&#39;server&#39;)</code> 就可获取我们配置好的日志器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># log_demo.py 文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;server&#x27;</span>)  <span class="comment"># 维护一个全局日志对象</span></span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&#x27;debug log test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_test1</span>():</span><br><span class="line">    logger.info(<span class="string">&#x27;info log test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_test2</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogDemo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">log_test</span>():</span><br><span class="line">        logger.warning(<span class="string">&#x27;warning log test&#x27;</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># log_test.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    setup_logging()</span><br><span class="line"></span><br><span class="line">    logger = logging.getLogger(<span class="string">&#x27;server&#x27;</span>)</span><br><span class="line">    logger.debug(<span class="string">&#x27;debug log test&#x27;</span>)</span><br><span class="line">    logger.info(<span class="string">&#x27;info log test&#x27;</span>)</span><br><span class="line">    logger.warning(<span class="string">&#x27;warning log test&#x27;</span>)</span><br><span class="line">    logger.error(<span class="string">&#x27;error log test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 日志在其他模块中使用演示</span></span><br><span class="line">    <span class="keyword">import</span> log_demo</span><br><span class="line">    log_demo.log_test1()</span><br><span class="line">    log_demo.log_test2()</span><br><span class="line">    log_demo.LogDemo.log_test()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()    </span><br></pre></td></tr></table></figure>



<h3 id="日志效果展示"><a href="#日志效果展示" class="headerlink" title="日志效果展示"></a>日志效果展示</h3><p>运行 <code>log_test.py</code> 结果如下</p>
<p><strong>控制台信息</strong></p>
<p><a href="https://camo.githubusercontent.com/ae64f35e9b97106fedf6d0117d57b0638b9285b0bdcecb9f6195f17ce2531e72/68747470733a2f2f70362d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f31663436653538633739333734343830393863316433333766636163633932667e74706c762d6b3375316662706663702d77617465726d61726b2e696d616765"><img src="https://camo.githubusercontent.com/ae64f35e9b97106fedf6d0117d57b0638b9285b0bdcecb9f6195f17ce2531e72/68747470733a2f2f70362d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f31663436653538633739333734343830393863316433333766636163633932667e74706c762d6b3375316662706663702d77617465726d61726b2e696d616765" alt="带颜色的日志信息"></a></p>
<p><strong>全部日志配置文件信息</strong></p>
<p><a href="https://camo.githubusercontent.com/70d45751490fe41de35c4d6ab10a29f47ff9b20e203dfe89a8463fea0f14636a/68747470733a2f2f70312d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f34653139326435656530333234633536383037346564336561626361656337337e74706c762d6b3375316662706663702d77617465726d61726b2e696d616765"><img src="https://camo.githubusercontent.com/70d45751490fe41de35c4d6ab10a29f47ff9b20e203dfe89a8463fea0f14636a/68747470733a2f2f70312d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f34653139326435656530333234633536383037346564336561626361656337337e74706c762d6b3375316662706663702d77617465726d61726b2e696d616765" alt="全部日志文件信息"></a></p>
<p><strong>错误日志文件信息</strong></p>
<p><a href="https://camo.githubusercontent.com/0ea4df88d6c05538a2d09a4b23a69c0fde2919fd8c113a6458f40d627e25ad3c/68747470733a2f2f70312d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f61656337323036363236316134646430383534613162633934633935646133367e74706c762d6b3375316662706663702d77617465726d61726b2e696d616765"><img src="https://camo.githubusercontent.com/0ea4df88d6c05538a2d09a4b23a69c0fde2919fd8c113a6458f40d627e25ad3c/68747470733a2f2f70312d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f61656337323036363236316134646430383534613162633934633935646133367e74706c762d6b3375316662706663702d77617465726d61726b2e696d616765" alt="错误日志文件信息"></a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>日志</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>动漫之家《镖人》爬虫</title>
    <url>/2023/03/31/%E5%8A%A8%E6%BC%AB%E4%B9%8B%E5%AE%B6%E3%80%8A%E9%95%96%E4%BA%BA%E3%80%8B%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>初学python时写的爬虫小程序，爬取动漫之家  《镖人》漫画所有文件到本地，单线程爬取，速度一般，如果用多线程会有很大速度提升，抽取爬虫逻辑可爬全站漫画资源</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前漫画总链接文本</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_url</span>(<span class="params">url</span>):</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&quot;</span>&#125;</span><br><span class="line">    res = requests.get(url, headers=headers)</span><br><span class="line">    res.encoding = res.apparent_encoding</span><br><span class="line">    <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> res.text</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬取所有章节标题、链接</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page</span>(<span class="params">html</span>):</span><br><span class="line">    title_list, href_list = [], []</span><br><span class="line"></span><br><span class="line">    soups = BeautifulSoup(html, <span class="string">&quot;lxml&quot;</span>)</span><br><span class="line">    soups = soups.find(attrs=&#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;list_con_li autoHeight&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> soup <span class="keyword">in</span> soups.select(<span class="string">&quot;li a&quot;</span>):</span><br><span class="line">        title_list.insert(<span class="number">0</span>, soup[<span class="string">&#x27;title&#x27;</span>])</span><br><span class="line">        href_list.insert(<span class="number">0</span>, soup[<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> title_list, href_list  <span class="comment"># 返回列表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否为数字型字符串</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_number</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">float</span>(s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬取章节内所有图片</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main_download</span>(<span class="params">name, url</span>):</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Referer&quot;</span>: url&#125;  <span class="comment"># 浏览器标识</span></span><br><span class="line">    res = requests.get(url, headers=headers)</span><br><span class="line">    html = res.text  <span class="comment"># 动态页面，返回js代码</span></span><br><span class="line">    link = re.findall(<span class="string">&quot;function\(p,a,c,k,e,d\).*?split&quot;</span>, html)  <span class="comment"># 匹配图片代码片段</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;解码js，构造图片真实链接&quot;&quot;&quot;</span></span><br><span class="line">    first_number = link[<span class="number">0</span>].split(<span class="string">&quot;&#x27;.split&quot;</span>)</span><br><span class="line">    first_number = first_number[<span class="number">0</span>].split(<span class="string">&quot;||&quot;</span>)</span><br><span class="line">    links, second = [], []</span><br><span class="line">    first = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> first_number:</span><br><span class="line">        number = i.split(<span class="string">&quot;|&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> number:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> is_number(num) <span class="keyword">and</span> <span class="built_in">len</span>(num) == <span class="number">4</span>:</span><br><span class="line">                    first = num  <span class="comment"># 链接开始四位数数字串</span></span><br><span class="line">                <span class="keyword">elif</span> is_number(num) <span class="keyword">and</span> (<span class="built_in">len</span>(num) == <span class="number">5</span> <span class="keyword">or</span> <span class="built_in">len</span>(num) == <span class="number">6</span>):</span><br><span class="line">                    second.append(<span class="built_in">int</span>(num))  <span class="comment"># 链接中间数字串</span></span><br><span class="line">                <span class="keyword">elif</span> is_number(num) <span class="keyword">and</span> <span class="built_in">len</span>(num) &gt;= <span class="number">7</span>:</span><br><span class="line">                    links.append(num)  <span class="comment"># 链接末尾数字串</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    links = <span class="built_in">sorted</span>(links)  <span class="comment"># 由小到大排序</span></span><br><span class="line">    <span class="comment"># 开始下载图片</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> links:</span><br><span class="line">        imgs_link = <span class="string">f&#x27;https://images.dmzj.com/img/chapterpic/<span class="subst">&#123;first&#125;</span>/<span class="subst">&#123;second[<span class="number">0</span>]&#125;</span>/<span class="subst">&#123;i&#125;</span>.jpg&#x27;</span>  <span class="comment"># 构造真实链接</span></span><br><span class="line"></span><br><span class="line">        response = requests.get(url=imgs_link, headers=headers)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;镖人/<span class="subst">&#123;name&#125;</span>/<span class="subst">&#123;i&#125;</span>.jpg&quot;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(response.content)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>: 已经下载完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主循环</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;镖人&quot;</span>):  <span class="comment"># 创建总文件夹</span></span><br><span class="line">        os.mkdir(<span class="string">&quot;镖人&quot;</span>)</span><br><span class="line">    url = <span class="string">&quot;https://www.dmzj.com/info/biaoren.html&quot;</span></span><br><span class="line">    html = get_url(url)</span><br><span class="line">    title_list, href_list = get_page(html)</span><br><span class="line">    <span class="comment">#processing = tqdm(range(0,len(title_list)))</span></span><br><span class="line">    <span class="keyword">for</span> name, url <span class="keyword">in</span> <span class="built_in">zip</span>(title_list, href_list,):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&quot;镖人/<span class="subst">&#123;name&#125;</span>&quot;</span>):</span><br><span class="line">            os.mkdir(<span class="string">f&quot;镖人/<span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">        main_download(name, url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确停止线程</title>
    <url>/2023/05/11/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="如何正确停止线程"><a href="#如何正确停止线程" class="headerlink" title="如何正确停止线程"></a>如何正确停止线程</h2><h4 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h4><h5 id="新建线程的方式有多种"><a href="#新建线程的方式有多种" class="headerlink" title="新建线程的方式有多种"></a>新建线程的方式有多种</h5><ul>
<li>实现Runnable接口，重写run()方法</li>
<li>继承Thread类，重写run()方法</li>
<li>实现callable接口，重写call方法</li>
<li>使用线程池</li>
<li>使用定时器</li>
<li>…………..</li>
</ul>
<h5 id="代码举例-Runnable接口"><a href="#代码举例-Runnable接口" class="headerlink" title="代码举例-Runnable接口"></a>代码举例-Runnable接口</h5><p>Runnable接口重写run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am NewRunnable Thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NewRunnable</span> <span class="variable">newRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(newRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    I am NewRunnable Thread</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上述代码中新建<code>NewRunnable</code> 类实现了<code>Runnable</code>接口后重写了run方法，实现新建一个线程，可能这样体现不出来多线程，可以加个循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewThread</span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;i am &quot;</span>+ i);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;i am mainThread&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i am <span class="number">0</span></span><br><span class="line">i am <span class="number">1</span></span><br><span class="line">i am mainThread</span><br><span class="line">i am <span class="number">2</span></span><br><span class="line">i am <span class="number">3</span></span><br><span class="line">i am <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>使用了匿名内部类重写了Runnable接口run方法，然后循环五次，每次睡眠200毫秒，主线程中睡眠500毫秒，所以当子线程循环两次后，在第三次打印中间主线程开始打印。</p>
<h5 id="代码举例-Thread类"><a href="#代码举例-Thread类" class="headerlink" title="代码举例-Thread类"></a>代码举例-Thread类</h5><p>继承Thread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am NewThread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NewThread</span> <span class="variable">newThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewThread</span>();</span><br><span class="line">        newThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   I am NewThread!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="新建线程总结"><a href="#新建线程总结" class="headerlink" title="新建线程总结"></a>新建线程总结</h5><p>无论是实现Runnable接口还是继承Thread类，发现最终都是通过Thread类的start()方法开启的线程，而不是通过run()方法，看一下run方法和start方法的源代码</p>
<h6 id="run-方法"><a href="#run-方法" class="headerlink" title="run()方法"></a>run()方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">        init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现Thread也实现了Runnable接口，并重写了run方法，如上所示，我们在使用实现Runnable接口，并把对象当作参数传给Thread类中 public Thread(Runnable target)；构造器时，这时候run()方法执行的就是传入对象的run()方法，run()方法中也只有这三行代码，所以并没有实现多线程。</p>
<h6 id="start-方法"><a href="#start-方法" class="headerlink" title="start()方法"></a>start()方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">     * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">     * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到首先run()方法<code>if (threadStatus != 0)</code> 判断线程状态，而后调用了start0方法，而start0方法<code>private native void start0();</code>可以看到是一个native方法，并非是由java实现</p>
<p>搜索后得知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在Java中，Thread类是用于实现多线程编程的类。当我们创建一个新线程并启动它时，实际上是调用了Thread类中的start()方法，该方法会执行一个本地方法start0()。start0()方法会启动一个新的系统线程，并调用run()方法。run()方法是线程执行的代码，当run()方法执行完毕后，线程就会自动结束。</span><br><span class="line"></span><br><span class="line">start0()方法是一个本地方法（<span class="keyword">native</span> method），它是由JVM实现的。本地方法是指使用C/C++等低级语言编写的方法，它们通常由JVM加载并在本地系统上执行。start0()方法在底层实现了线程的创建和启动，其具体实现会依赖于不同的操作系统和JVM实现。在JVM中，start0()方法的实现是由<span class="keyword">native</span>层面提供的，因此我们无法直接查看其源代码。</span><br></pre></td></tr></table></figure>

<p>所以我们可以得知，在java中真正实现多线程的是Thread类中的start()方法。</p>
<h5 id="补充-callable接口"><a href="#补充-callable接口" class="headerlink" title="补充 callable接口"></a>补充 callable接口</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;I am newCallable!&quot;</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NewCallable</span> <span class="variable">newCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewCallable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(newCallable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;i am mainThread&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Thread-0</span></span><br><span class="line"><span class="comment">    I am newCallable!</span></span><br><span class="line"><span class="comment">    i am mainThread</span></span><br><span class="line"><span class="comment">    main</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以看到实现callable接口也是通过Thread类创建的新线程，不同的是使用了<code>FutureTask</code>类接收了返回值</p>
<p>简要说一下<code>futureTask</code>可以看到该类间接继承了Runnable接口，所以依然可以理解成callable接口就是实现<code>Runnbale</code>接口，重写了run方法的方式实现了多线程，其他方式不在过多阐释。</p>
<p><img src="https://pic2.imgdb.cn/item/645c4b0a0d2dde577754bbae.png"></p>
<h4 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h4><h5 id="如何停止线程？"><a href="#如何停止线程？" class="headerlink" title="如何停止线程？"></a>如何停止线程？</h5><ul>
<li>stop()?</li>
<li>destroy()?</li>
<li>suspend()?</li>
<li>interrupt()?</li>
</ul>
<p>查看 API，我们会看到 <code>java.lang.Thread</code> 类型提供了一系列的方法如 start()、stop()、resume()、suspend()、destroy()等方法来管理线程。但是除了 start() 之外，其它几个方法都被声名为已过时（deprecated）</p>
<p>详细原因可看<code>jdk</code>文档的解释  </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">https://docs.oracle.com/javase/<span class="number">1.5</span>.<span class="number">0</span>/docs/guide/misc/threadPrimitiveDeprecation.html</span><br></pre></td></tr></table></figure>

<p><strong>正确停止线程的方式是使用interrupt()方法</strong></p>
<h5 id="Interrupt-方法"><a href="#Interrupt-方法" class="headerlink" title="Interrupt()方法"></a>Interrupt()方法</h5><p>在 Java 中，<code>Thread.interrupt()</code> 方法用于中断线程，其作用是设置线程的中断标志位为 <code>true</code>。被中断的线程可以通过检查自身的中断标志位来判断是否被中断，然后执行适当的操作。</p>
<p>如果线程被阻塞在某些操作上（如等待 I&#x2F;O 操作、<code>sleep()</code> 等），调用 <code>interrupt()</code> 方法会中断该线程的阻塞状态，抛出 <code>InterruptedException</code> 异常，并清除中断标志位。如果线程没有被阻塞，则调用 <code>interrupt()</code> 方法只是设置线程的中断标志位为 <code>true</code>，线程仍然可以继续运行。</p>
<h5 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;MyThread is running...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread is interrupted!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        myThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    MyThread is running...</span></span><br><span class="line"><span class="comment">    MyThread is running...</span></span><br><span class="line"><span class="comment">    MyThread is running...</span></span><br><span class="line"><span class="comment">    MyThread is running...</span></span><br><span class="line"><span class="comment">    MyThread is running...</span></span><br><span class="line"><span class="comment">    MyThread is interrupted!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新建了一个线程，在主线程中，我们睡眠5S后将新建线程中断，这是新线程捕获中断，并打印了<code>MyThread is interrupted!</code>，</p>
<h5 id="中断标志位"><a href="#中断标志位" class="headerlink" title="中断标志位"></a>中断标志位</h5><p>上方代码中，如果我们把<code>while (!Thread.currentThread().isInterrupted())</code> 换成 <code>while (true)</code>发现运行结果是一样的，为什么呢？这就牵扯到中断标志位了，如上方所言 <strong>如果线程被阻塞在某些操作上（如等待 I&#x2F;O 操作、<code>sleep()</code> 等），调用 <code>interrupt()</code> 方法会中断该线程的阻塞状态，抛出 <code>InterruptedException</code> 异常，并清除中断标志位。</strong>上方代码中5s中断线程时，线程在sleep状态，这时候程序抛出 <code>InterruptedException</code> 异常，并清除中断标志位。在抛出异常时线程已经停止了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;正在打印：&quot;</span>+ ++i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        myThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">正在打印：0</span></span><br><span class="line"><span class="comment">正在打印：1</span></span><br><span class="line"><span class="comment">正在打印：2</span></span><br><span class="line"><span class="comment">正在打印：3</span></span><br><span class="line"><span class="comment">........</span></span><br><span class="line"><span class="comment">正在打印：104</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以看到我们通过判断程序的中断信号来执行代码，当程序被中断时，跳出while循环，新线程运行结束</p>
<h5 id="循环中使用注意事项"><a href="#循环中使用注意事项" class="headerlink" title="循环中使用注意事项"></a>循环中使用注意事项</h5><p>如果我们将try catch 放在循环中发现程序响应中断后并未停止，这是因为sleep（）清除了中断标志位，所以不能将try catch语句放在循环中，而应该放在循环外。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;MyThread is running...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        myThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">MyThread is running...</span></span><br><span class="line"><span class="comment">MyThread is running...</span></span><br><span class="line"><span class="comment">MyThread is running...</span></span><br><span class="line"><span class="comment">MyThread is running...</span></span><br><span class="line"><span class="comment">java.lang.InterruptedException: sleep interrupted</span></span><br><span class="line"><span class="comment">	at java.lang.Thread.sleep(Native Method)</span></span><br><span class="line"><span class="comment">	at threadToStop.MyThread.run(MyThread.java:8)</span></span><br><span class="line"><span class="comment">MyThread is running...</span></span><br><span class="line"><span class="comment">MyThread is running...</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>《算法图解》学习（一）</title>
    <url>/2023/02/17/%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="《算法图解》学习（一）"><a href="#《算法图解》学习（一）" class="headerlink" title="《算法图解》学习（一）"></a>《算法图解》学习（一）</h2><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>二分查找又称折半查找、二分搜索、折半搜索等，是在<a href="http://c.biancheng.net/algorithm/divide-and-conquer.html">分治算法</a>基础上设计出来的查找算法，对应的时间复杂度为<code>O(logn)</code></p>
<h5 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h5><h6 id="假定一列有序的数据如下："><a href="#假定一列有序的数据如下：" class="headerlink" title="假定一列有序的数据如下："></a>假定一列有序的数据如下：</h6><table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
</tr>
</thead>
</table>
<h6 id="查找一个数字在里面的位置，例如7"><a href="#查找一个数字在里面的位置，例如7" class="headerlink" title="查找一个数字在里面的位置，例如7"></a>查找一个数字在里面的位置，例如<strong>7</strong></h6><p>记录两个起始位置，<code>start</code>  <code>end</code>，和一个中间位置<code>middle</code>(<code>(start + end)/2</code>) 取整</p>
<table>
<thead>
<tr>
<th>第一轮</th>
<th align="center">start</th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center">middle</th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center">end</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
<td align="center">7</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">10</td>
</tr>
</tbody></table>
<h6 id="每次比较中间的数和目标值的大小，则无论大或者小，总会排除一半的数据剩下-（target-gt-middle）middle-1-end-或者（target-lt-middle-start-middle-1-例如本次示例-7-gt-5-middle-则剩下"><a href="#每次比较中间的数和目标值的大小，则无论大或者小，总会排除一半的数据剩下-（target-gt-middle）middle-1-end-或者（target-lt-middle-start-middle-1-例如本次示例-7-gt-5-middle-则剩下" class="headerlink" title="每次比较中间的数和目标值的大小，则无论大或者小，总会排除一半的数据剩下 （target&gt;middle）middle+1~end 或者（target&lt;middle) start ~middle -1,  例如本次示例  7&gt;5(middle)则剩下"></a>每次比较中间的数和目标值的大小，则无论大或者小，总会排除一半的数据剩下 （target&gt;middle）middle+1~end 或者（target&lt;middle) start ~middle -1,  例如本次示例  7&gt;5(middle)则剩下</h6><table>
<thead>
<tr>
<th>第一轮</th>
<th>start</th>
<th></th>
<th></th>
<th></th>
<th>middle</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>end</th>
</tr>
</thead>
<tbody><tr>
<td><strong>第二轮</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>start</strong></td>
<td></td>
<td><strong>middle</strong></td>
<td></td>
<td><strong>end</strong></td>
</tr>
<tr>
<td></td>
<td><del>1</del></td>
<td><del>2</del></td>
<td><del>3</del></td>
<td><del>4</del></td>
<td><del>5</del></td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
</tbody></table>
<h6 id="以此类推，下一次循环为：剩下-6-和-7-并且-start和middle都是6"><a href="#以此类推，下一次循环为：剩下-6-和-7-并且-start和middle都是6" class="headerlink" title="以此类推，下一次循环为：剩下  6  和 7 并且  start和middle都是6"></a>以此类推，下一次循环为：剩下  6  和 7 并且  start和middle都是6</h6><table>
<thead>
<tr>
<th>第一轮</th>
<th>start</th>
<th></th>
<th></th>
<th></th>
<th>middle</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>end</th>
</tr>
</thead>
<tbody><tr>
<td><strong>第二轮</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>start</strong></td>
<td></td>
<td><strong>middle</strong></td>
<td></td>
<td><strong>end</strong></td>
</tr>
<tr>
<td><strong>第三轮</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>start(middle)</strong></td>
<td><strong>end</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><del>1</del></td>
<td><del>2</del></td>
<td><del>3</del></td>
<td><del>4</del></td>
<td><del>5</del></td>
<td>6</td>
<td>7</td>
<td><del>8</del></td>
<td><del>9</del></td>
<td><del>10</del></td>
</tr>
</tbody></table>
<h6 id="在下一轮，6-lt-7-start-1-这时-start-x3D-end-x3D-7-命中目标，跳出循环"><a href="#在下一轮，6-lt-7-start-1-这时-start-x3D-end-x3D-7-命中目标，跳出循环" class="headerlink" title="在下一轮，6 &lt;7  start+1 这时 start &#x3D; end &#x3D;7 命中目标，跳出循环"></a>在下一轮，6 &lt;7  start+1 这时 start &#x3D; end &#x3D;7 命中目标，跳出循环</h6><table>
<thead>
<tr>
<th>第一轮</th>
<th>start</th>
<th></th>
<th></th>
<th></th>
<th>middle</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>end</th>
</tr>
</thead>
<tbody><tr>
<td><strong>第二轮</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>start</strong></td>
<td></td>
<td><strong>middle</strong></td>
<td></td>
<td><strong>end</strong></td>
</tr>
<tr>
<td><strong>第三轮</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>start(middle)</strong></td>
<td><strong>end</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>第四轮</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>target</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><del>1</del></td>
<td><del>2</del></td>
<td><del>3</del></td>
<td><del>4</del></td>
<td><del>5</del></td>
<td><del>6</del></td>
<td>7</td>
<td><del>8</del></td>
<td><del>9</del></td>
<td><del>10</del></td>
</tr>
</tbody></table>
<h5 id="代码示例-返回查找次数"><a href="#代码示例-返回查找次数" class="headerlink" title="代码示例 (返回查找次数)"></a>代码示例 (返回查找次数)</h5><h5 id="python"><a href="#python" class="headerlink" title="python:"></a>python:</h5><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">binary</span>(<span class="params"><span class="built_in">list</span>, num</span>):</span><br><span class="line">    low = <span class="built_in">list</span>[<span class="number">0</span>]</span><br><span class="line">    step = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">list</span>[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        middle = <span class="built_in">int</span>((low + high) / <span class="number">2</span>)</span><br><span class="line">        step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> num &gt; middle:</span><br><span class="line">            low = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> num &lt; middle:</span><br><span class="line">            high = middle - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;low:<span class="subst">&#123;low&#125;</span> high:<span class="subst">&#123;high&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">list</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]</span><br><span class="line">    <span class="built_in">print</span>(binary(<span class="built_in">list</span>, <span class="number">15</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Java："><a href="#Java：" class="headerlink" title="Java："></a>Java：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.binary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinarySearch</span> <span class="variable">binarySearch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySearch</span>();</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(binarySearch.serach(list, <span class="number">11</span>));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">serach</span><span class="params">(List&lt;Integer&gt; list, Integer num)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span>  list.get(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> list.get(list.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (low + high)/<span class="number">2</span>;</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; middle)&#123;</span><br><span class="line">                low = middle+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &lt; middle)&#123;</span><br><span class="line">                high = middle -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul>
<li><p>逻辑：</p>
<ul>
<li>双层循环</li>
</ul>
</li>
<li><p>步骤：</p>
<ul>
<li>​    最里面循环（递增）：</li>
<li>​        比较相邻两个数据 (<code>[i]</code> <code>[i+1]</code>)得大小，如果大于则交换位置，</li>
<li>​        这样保证一次循环后 最大得数据过滤到了最后，下次循环只需要排序list[:-1]</li>
<li>​        依次下次执行，数据会从后往前，完整排序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 冒泡排序</span><br><span class="line">sortNum = [12, 23, 14, 43, 24, 64, 124, 1, 544, 87, 53]</span><br><span class="line"></span><br><span class="line">def bubbleSort(sorts):</span><br><span class="line">    for i in range(len(sortNum)):</span><br><span class="line">        for j in range(len(sortNum[i:-1])):</span><br><span class="line">            if sortNum[j] &lt; sortNum[j + 1]:</span><br><span class="line">                temp = sortNum[j]</span><br><span class="line">                sortNum[j] = sortNum[j + 1]</span><br><span class="line">                sortNum[j + 1] = temp</span><br><span class="line"></span><br><span class="line">    return sorts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(bubbleSort(sortNum))</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h6 id="原理：递归将原字段分割成最小得部分（单个数据或者空）"><a href="#原理：递归将原字段分割成最小得部分（单个数据或者空）" class="headerlink" title="原理：递归将原字段分割成最小得部分（单个数据或者空）"></a>原理：递归将原字段分割成最小得部分（单个数据或者空）</h6><ul>
<li>递归出口：<ul>
<li>​    传入列表为空或者单个数据</li>
</ul>
</li>
<li>递归逻辑：<ul>
<li>​     选择一个基准值用作比较</li>
<li>​     过滤出大于和小于改基准值得数据分成两组，</li>
<li>​     将两组数据递归执行，1，2步骤，直到分成最小部分</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sortNum = [12, 23, 14, 43, 24, 64, 124, 1, 544, 87, 53]</span><br><span class="line"></span><br><span class="line">def fastSort(sort_num):</span><br><span class="line">    if len(sort_num) &lt; 2:</span><br><span class="line">        return sort_num</span><br><span class="line"></span><br><span class="line">    base_num = sort_num[0]</span><br><span class="line">    lift_list = [i for i in sort_num if i &lt; base_num]</span><br><span class="line">    right_list = [i for i in sort_num if i &gt; base_num]</span><br><span class="line"></span><br><span class="line">    return fastSort(lift_list) + [base_num] + fastSort(right_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(fastSort(sortNum))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>如何超过大多数人</title>
    <url>/2023/05/19/%E5%A6%82%E4%BD%95%E8%B6%85%E8%BF%87%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何超过大多数人"><a href="#如何超过大多数人" class="headerlink" title="如何超过大多数人"></a>如何超过大多数人</h1><h5 id="转载自-https-coolshell-cn-articles-19464-html-原作者：陈皓（左耳朵耗子）酷-壳-–-CoolShell"><a href="#转载自-https-coolshell-cn-articles-19464-html-原作者：陈皓（左耳朵耗子）酷-壳-–-CoolShell" class="headerlink" title="转载自 https://coolshell.cn/articles/19464.html  原作者：陈皓（左耳朵耗子）酷 壳 – CoolShell****"></a><em><strong>转载自 <a href="https://coolshell.cn/articles/19464.html">https://coolshell.cn/articles/19464.html</a>  原作者：陈皓（左耳朵耗子）</strong><a href="https://link.juejin.cn/?target=https://coolshell.cn/">酷 壳 – CoolShell</a></em>****</h5><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">ps:读这篇文章前先看看下面这段话，避免误导大家。</span><br><span class="line"></span><br><span class="line">切记，这篇文章不要过度深思（任何东西都无法经得起审视，因为这世上没有同样的成长环境，也没有同样的认知水平同时也**没有适用于所有人的解决方案**；也不要去急着评判里面列出的观点，只需代入到其中适度审视一番自己即可，能**跳脱出来从外人的角度看看现在的自己处在什么样的阶段**就行。具体怎么想怎么做全在你自己去**不断实践中寻找那个适合自己的方案**）</span><br><span class="line"></span><br><span class="line">引用自：https://juejin.cn/post/7207648496978870333</span><br></pre></td></tr></table></figure>



<p>当你看到这篇文章的标题，你一定对这篇文章产生了巨大的兴趣，因为你的潜意识在告诉你，这是一本人生的“武林秘籍”，而且还是左耳朵写的，一定有干货满满，只要读完，一定可以练就神功并找到超过大多数人的快车道和捷径……然而…… 当你看到我这样开篇时，你一定会觉得我马上就要有个转折，告诉你这是不可能的，一切都需要付出和努力……然而，你错了，这篇文章还真就是一篇“秘籍”，只要你把这些“秘籍”用起来，你就一定可以超过大多数人。而且，这篇文章只有我这个“人生导师”可以写得好。毕竟，我的生命过到了十六进制2B的年纪，踏入这个社会已超过20年，舍我其谁呢？！</p>
<p>P.S. 这篇文章借鉴于《<a href="https://coolshell.cn/articles/4758.html">如何写出无法维护的代码</a>》一文的风格……嘿嘿</p>
<h4 id="相关技巧和最佳实践"><a href="#相关技巧和最佳实践" class="headerlink" title="相关技巧和最佳实践"></a>相关技巧和最佳实践</h4><p>要超过别人其实还是比较简单的，尤其在今天的中国，更是简单。因为，你只看看中国的互联网，你就会发现，他们基本上全部都是在消费大众，让大众变得更为地愚蠢和傻瓜。<strong>所以，在今天的中国，你基本上不用做什么，只需要不使用中国互联网，你就很自然地超过大多数人了</strong>。当然，如果你还想跟他们彻底拉开，甩他们几个身位，把别人打到底层，下面的这些“技巧”你要多多了解一下。</p>
<p>在信息获取上，你要不断地向大众鼓吹下面的这些事：</p>
<ul>
<li>让大家都用百度搜索引擎查找信息，订阅微信公众号或是到知乎上学习知识……要做到这一步，你就需要把“百度一下”挂在嘴边，然后要经常在群或朋友圈中转发微信公众号的文章，并且转发知乎里的各种“如何看待……”这样的文章，让他们爱上八卦，爱上转发，爱上碎片。</li>
<li>让大家到微博或是知识星球上粉一些大咖，密切关注他们的言论和动向……是的，告诉大家，大咖的任何想法一言一行都可以在微博、朋友圈或是知识星球上获得，让大家相信，你的成长和大咖的见闻和闲扯非常有关系，你跟牛人在一个圈子里你也会变牛。</li>
<li>把今日头条和抖音这样的APP推荐给大家……你只需要让你有朋友成功地安装这两个APP，他们就会花大量的时间在上面，而不能自拔，要让他们安装其实还是很容易的，你要不信你就装一个试玩一会看看（嘿嘿嘿）。</li>
<li>让大家热爱八卦，八卦并不一定是明星的八卦，还可以是你身边的人，比如，公司的同事，自己的同学，职场见闻，社会热点，争议话题，……这些东西总有一些东西会让人心态有很多微妙的变化，甚至花大量的时间去搜索和阅读大量的观点，以及花大量时间与人辩论争论，这个过程会让人上瘾，让人欲罢不能，然而这些事却和自己没有半毛钱关系。你要做的事就是转发其中一些SB或是很极端的观点，造成大家的一睦讨论后，就早早离场……</li>
<li>利用爱国主义，让大家觉得不用学英文，不要出国，不要翻墙，咱们已经是强国了……这点其实还是很容易做到的，因为学习是比较逆人性的，所以，只要你鼓吹那些英文无用论，出国活得更惨，国家和民族都变得很强大，就算自己过得很底层，也有大国人民的感觉。</li>
</ul>
<p>然后，在知识学习和技能训练上，让他们不得要领并产生幻觉</p>
<ul>
<li>让他们混淆认识和知识，以为开阔认知就是学习，让他们有学习和成长的幻觉……</li>
<li>培养他们要学会使用碎片时间学习。等他们习惯利用碎片时间吃快餐后，他们就会失去精读一本书的耐性……</li>
<li>不断地给他们各种各样“有价值的学习资料”，让他们抓不住重点，成为一个微信公众号或电子书“收藏家”……</li>
<li>让他们看一些枯燥无味的基础知识和硬核知识，这样让他们只会用“死记硬背”的方式来学习，甚至直接让他们失去信心，直接放弃……</li>
<li>玩具手枪是易用的，重武器是难以操控的，多给他们一些玩具，这样他们就会对玩具玩地得心应手，觉得玩玩具就是自己的专业……</li>
<li>让他们喜欢直接得到答案的工作和学习方式，成为一个伸手党，从此学习再也不思考……</li>
<li>告诉他们东西做出来就好了，不要追求做漂亮，做优雅，这样他们就会慢慢地变成劳动密集型……</li>
<li>让他们觉得自己已经很努力了，剩下的就是运气，并说服他们去‘及时行乐’，然后再也找不到高阶和高效率学习的感觉……</li>
<li>让他们觉得“读完书”、“读过书”就行了，不需要对书中的东西进行思考，进行总结，或是实践，只要囫囵吞枣尽快读完就等同于学好了……</li>
</ul>
<p>最后，在认知和格局上，彻底打垮他们，让他们变成韭菜。</p>
<ul>
<li>让他们尽可能地用拼命和加班，尽可能的996，并告诉他们这就是通往成功的唯一路径。这样一来，他们必然会被永远困在低端成为最低的劳动力。</li>
<li>让他们不要看到大的形势，只看到眼前的一亩三分地，做好一个井底之蛙。其实这很简单，就是不要告诉他还有另外一种活法，不要扩大他的认识……</li>
<li>宣扬一夜暴富以及快速挣钱的案例，最好让他们进入“赌博类”或是“传销类”的地方，比如：股市、数字货币……要让他们相信各种财富神话，相信他们就是那个幸运儿，他们也可以成为巴菲特，可以成为马云……</li>
<li>告诉他们，一些看上去很难的事都是有捷径的，比如：21天就能学会机器学习，用区块链就能颠覆以及重构整个世界等等……</li>
<li>多跟他们讲一些小人物的励志的故事，这样让他们相信，不需要学习高级知识，不需要掌握高级技能，只需要用低等的知识和低级的技能，再加上持续不断拼命重复现有的工作，终有一天就会成功……</li>
<li>多让他们跟别人比较，人比人不会气死人，但是会让人变得浮躁，变得心急，变得焦虑，当一个人没有办法控制自己的情绪，没有办法让自己静下心来，人会失去耐性和坚持，开始好大喜欢功，开始装逼，开始歪门邪道剑走偏锋……</li>
<li>让他们到体制内的一些非常稳定的地方工作，这样他们拥有不思进取、怕承担责任、害怕犯错、喜欢偷懒、得过且过的素质……</li>
<li>让他们到体制外的那些喜欢拼命喜欢加班的地方工作，告诉他们爱拼才会赢，努力加班是一种福报，青春就是用来拼的，让他们喜欢上使蛮力的感觉……</li>
<li>告诉他们你的行业太累太辛苦，干不到30岁。让他们早点转行，不要耽误人生和青春……</li>
<li>当他们要做决定的时候，一定要让他们更多的关注自己会失去的东西，而不是会得到的东西。培养他们患得患失心态，让他们认识不到事物真正的价值，失去判断能力……（比如：让他们觉得跟对人拍领导的马屁忠于公司比自我的成长更有价值）</li>
<li>告诉他们，你现有的技能和知识不用更新，就能过好一辈子，新出来的东西没有生命力的……这样他们就会像我们再也不学习的父辈一样很快就会被时代所抛弃……</li>
<li>每个人都喜欢在一些自己做不到的事上找理由，这种能力不教就会，比如，事情太多没有时间，因为工作上没有用到，等等，你要做的就是帮他们为他们做不到的事找各种非常合理的理由，比如：没事的，一切都是最好的安排；你得不到的那个事没什么意思；你没有面好主要原因是那个面试官问的问题都是可以上网查得到的知识，而不没有问到你真正的能力上；这些东西学了不用很快会忘了，等有了环境再学也不迟……</li>
</ul>
<p><strong>最后友情提示一下，上述的这些“最佳实践”你要小心，是所谓，贩毒的人从来不吸毒，开赌场的人从来不赌博！所以，你要小心别自己也掉进去了！这就是“欲练神功，必先自宫”的道理。</strong></p>
<h4 id="相关原理和思维模型"><a href="#相关原理和思维模型" class="headerlink" title="相关原理和思维模型"></a>相关原理和思维模型</h4><p>对于上面的这些技巧还有很多很多，你自己也可以发明或是找到很多。所以，我来讲讲这其中的一些原理。</p>
<p>一般来说，超过别人一般来说就是两个维度：</p>
<ol>
<li><strong>在认知、知识和技能上</strong>。这是一个人赖以立足社会的能力（参看《<a href="https://coolshell.cn/articles/4235.html">程序员的荒谬之言还是至理名言？</a>》和《<a href="https://coolshell.cn/articles/2250.html">21天教你学会C++</a>》）</li>
<li><strong>在领导力上</strong>。所谓领导力就是你跑在别人前面，你得要有比别人更好的能力更高的标准（参看《<a href="https://coolshell.cn/articles/17583.html">技术人员发展之路</a>》）</li>
</ol>
<p>首先，我们要明白，人的技能是从认识开始，然后通过学校、培训或是书本把“零碎的认知”转换成“系统的知识”，而有要把知识转换成技能，就需要训练和实践，这样才能完成从：认识 -&gt; 知识 -&gt; 技能 的转换。这个转换过程是需要耗费很多时间和精力的，而且其中还需要有强大的学习能力和动手能力，这条路径上有很多的“关卡”，每道关卡都会过滤掉一大部分人。比如：对于一些比较枯燥的硬核知识来说，90%的人基本上就倒下来，不是因为他们没有智商，而是他们没有耐心。</p>
<h5 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h5><p>要在认知上超过别人，就要在下面几个方面上做足功夫：</p>
<p>1）<strong>信息渠道</strong>。试想如果别人的信息源没有你的好，那么，这些看不见信息源的人，只能接触得到二手信息甚至三手信息，只能获得被别人解读过的信息，这些信息被三传两递后必定会有错误和失真，甚至会被传递信息的中间人hack其中的信息（也就是“中间人攻击”），而这些找不出信息源的人，只能“被人喂养”，于是，他们最终会被困在信息的底层，永世不得翻身。（比如：学习C语言，放着原作者K&amp;R的不用，硬要用错误百出谭浩强的书，能有什么好呢？）</p>
<p>2）<strong>信息质量</strong>。信息质量主要表现在两个方面，一个是信息中的燥音，另一个是信息中的质量等级，我们都知道，在大数据处理中有一句名言，叫 garbage in garbage out，你天天看的都是垃圾，你的思想和认识也只有垃圾。所以，如果你的信息质量并不好的话，你的认知也不会好，而且你还要花大量的时间来进行有价值信息的挖掘和处理。</p>
<p>3）<strong>信息密度</strong>。优质的信息，密度一般都很大，因为这种信息会逼着你去干这么几件事，a）搜索并学习其关联的知识，b）沉思和反省，c）亲手去推理、验证和实践……一般来说，经验性的文章会比知识性的文章会更有这样的功效。比如，类似于像 Effiective C++&#x2F;Java，设计模式，Unix编程艺术，算法导论等等这样的书就是属于这种密度很大的书，而像<a href="https://medium.com/netflix-techblog">Netflix的官方blog</a>和<a href="https://www.allthingsdistributed.com/">AWS CTO的blog</a>等等地方也会经常有一些这样的文章。</p>
<h5 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h5><p>要在知识上超过别人，你就需要在下面几个方面上做足功夫：</p>
<p>1）<strong>知识树（图）</strong>。任何知识，只在点上学习不够的，需要在面上学习，这叫系统地学习，这需要我们去总结并归纳知识树或知识图，一个知识面会有多个知识板块组成，一个板块又有各种知识点，一个知识点会导出另外的知识点，各种知识点又会交叉和依赖起来，学习就是要系统地学习整个知识树（图）。而我们都知道，<strong>对于一棵树来说，“根基”是非常重要的，所以，学好基础知识也是非常重要的，对于一个陌生的地方，有一份地图是非常重要的，没有地图的你只会乱窜，只会迷路、练路、走冤枉路！</strong></p>
<p>2）<strong>知识缘由</strong>。任何知识都是有缘由的，了解一个知识的来龙去脉和前世今生，会让你对这个知识有非常强的掌握，而不再只是靠记忆去学习。靠记忆去学习是一件非常糟糕的事。而对于一些操作性的知识（不需要了解由来的），我把其叫操作知识，就像一些函数库一样，这样的知识只要学会查文档就好了。<strong>能够知其然，知其所以然的人自然会比识知识到表皮的人段位要高很多。</strong></p>
<p>3）<strong>方法套路</strong>。学习不是为了找到答案，而是找到方法。就像数学一样，你学的是方法，是解题思路，是套路，会用方程式解题的和不会用方程式解题的在解题效率上不可比较，而在微积分面前，其它的解题方法都变成了渣渣。<strong>你可以看到，掌握高级方法的人比别人的优势有多大，学习的目的就是为了掌握更为高级的方法和解题思路</strong>。</p>
<h5 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h5><p>要在技能上超过别人，你就需要在下面几个方面做足功夫：</p>
<p>1）<strong>精益求精</strong>。如果你想拥有专业的技能，你要做不仅仅是拼命地重复一遍又一遍的训练，而是在每一次重复训练时你都要找到更好的方法，总结经验，让新的一遍能够更好，更漂亮，更有效率，否则，用相同的方法重复，那你只不过在搬砖罢了。</p>
<p>2）<strong>让自己犯错</strong>。犯错是有利于成长的，这是因为出错会让人反思，反思更好的方法，反思更完美的方案，总结教训，寻求更好更完美的过程，是技能升级的最好的方式。尤其是当你在出错后，被人鄙视，被人嘲笑后，你会有更大的动力提升自己，这样的动力才是进步的源动力。当然，千万不要同一个错误重复地犯！</p>
<p>3）<strong>找高手切磋</strong>。下过棋，打个球的人都知道，你要想提升自己的技艺，你必需找高手切磋，在和高手切磋的过程中你会感受到高手的技能和方法，有时候你会情不自禁地哇地一下，我靠，还可以这么玩！</p>
<h5 id="领导力"><a href="#领导力" class="headerlink" title="领导力"></a>领导力</h5><p>最后一个是领导力，要有领导力或是影响力这个事并不容易，这跟你的野心有多大，好胜心有多强 ，你愿意付出多少很有关系，因为一个人的领导力跟他的标准很有关系，因为有领导力的人的标准比绝大多数人都要高。</p>
<p>1）<strong>识别自己的特长和天赋</strong>。首先，每个人DNA都可能或多或少都会有一些比大多数人NB的东西（当然，也可能没有），如果你有了，那么在你过去的人生中就一定会表现出来了，就是那种大家遇到这个事会来请教你的寻求你帮助的现象。那种，别人要非常努力，而且毫不费劲的事。一旦你有了这样的特长或天赋，那你就要大力地扩大你的领先优势，千万不要进到那些会限制你优势的地方。你是一条鱼，你就一定要把别人拉到水里来玩，绝对不要去陆地上跟别人拼，不断地在自己的特长和天赋上扩大自己的领先优势，彻底一骑绝尘。</p>
<p>2）<strong>识别自己的兴趣和事业</strong>。没有天赋也没有问题，还有兴趣点，都说兴趣是最好的老师，当年，Linus就是在学校里对minx着迷了，于是整出个Linux来，这就是兴趣驱动出的东西，一般来说，兴趣驱动的事总是会比那些被动驱动的更好。但是，这里我想说明一下什么叫“真∙兴趣”，真正的兴趣不是那种三天热度的东西，而是那种，你愿意为之付出一辈子的事，是那种无论有多大困难有多难受你都要死磕的事，这才是“真∙兴趣”，这也就是你的“野心”和“好胜心”所在，其实上升到了你的事业。相信我，绝大多数人只有职业而没有事业的。</p>
<p>3）<strong>建立高级的习惯和方法</strong>。没有天赋没有野心，也还是可以跟别人拼习惯拼方法的，只要你有一些比较好的习惯和方法，那么你一样可以超过大多数人。对此，在习惯上你要做到比较大多数人更自律，更有计划性，更有目标性，比如，每年学习一门新的语言或技术，并可以参与相关的顶级开源项目，每个月训练一个类算法，掌握一种算法，每周阅读一篇英文论文，并把阅读笔记整理出来……自律的是非常可怕的。除此之外，你还需要在方法上超过别人，你需要满世界的找各种高级的方法，其中包括，思考的方法，学习的方法、时间管理的方法、沟通的方法这类软实力的，还有，解决问题的方法（trouble shooting 和 problem solving），设计的方法，工程的方法，代码的方法等等硬实力的，一开始照猫画虎，时间长了就可能会自己发明或推导新的方法。</p>
<p>4）<strong>勤奋努力执着坚持</strong>。如果上面三件事你都没有也没有能力，那还有最后一件事了，那就是勤奋努力了，就是所谓的“一万小时定律”了（参看《<a href="https://coolshell.cn/articles/2250.html">21天教你学会C++</a>》中的十年学编程一节），我见过很多不聪明的人，悟性也不够（比如我就是一个），别人学一个东西，一个月就好了，而我需要1年甚至更长，但是很多东西都是死的，只要肯花时间就有一天你会搞懂的，耐不住我坚持十年二十年，聪明的人发明个飞机飞过去了，笨一点的人愚公移山也过得去，因为更多的人是懒人，我不用拼过聪明人，我只用拼过那些懒人就好了。</p>
<p>好了，就这么多，如果哪天你变得消极和不自信，你要来读读我的这篇文章，子曰：温故而知新。</p>
]]></content>
      <categories>
        <category>代码人生</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>对称加密和非对称加密</title>
    <url>/2023/03/10/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="对称加密AES和非对称加密RSA"><a href="#对称加密AES和非对称加密RSA" class="headerlink" title="对称加密AES和非对称加密RSA"></a>对称加密AES和非对称加密RSA</h2><h3 id="AES（-Advanced-Encryption-Standard-）"><a href="#AES（-Advanced-Encryption-Standard-）" class="headerlink" title="AES（ Advanced Encryption Standard ）"></a>AES（ Advanced Encryption Standard ）</h3><p><em>对称加密算法</em>，<em>加密和解密过程使用同一个密钥</em></p>
<p>AES为分组加密法，把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文，在AES标准规范中，分组长度只能是128位，AES是按照字节进行加密的，也就是说每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。这导致密钥长度不同，推荐加密的轮数也不同。</p>
<p><strong>因为明文和密钥必须是128位（密钥可以是192&#x2F;256 位），所以需要将分组明文和密钥进行补位</strong></p>
<h4 id="python代码实现"><a href="#python代码实现" class="headerlink" title="python代码实现"></a>python代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密  ECB模式  16代表16字节也就是128位</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_encode</span>(<span class="params">key, password</span>):</span><br><span class="line">    <span class="comment"># 将密钥填充到16的倍数</span></span><br><span class="line">    key = key + (<span class="number">16</span> - <span class="built_in">len</span>(key) % <span class="number">16</span>) * <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">    <span class="comment"># 创建AES密码器对象</span></span><br><span class="line">    cipher = AES.new(key.encode(), AES.MODE_ECB)</span><br><span class="line">    <span class="comment"># 将明文填充到16的倍数</span></span><br><span class="line">    password = password + (<span class="number">16</span> - <span class="built_in">len</span>(password) % <span class="number">16</span>) * <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">    <span class="comment"># 加密</span></span><br><span class="line">    ciphertext = cipher.encrypt(password.encode())</span><br><span class="line">    <span class="comment"># 将密文进行Base64编码</span></span><br><span class="line">    ciphertext = base64.b64encode(ciphertext)</span><br><span class="line">    <span class="keyword">return</span> ciphertext.decode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_decode</span>(<span class="params">key, ciphertext</span>):</span><br><span class="line">    <span class="comment"># 将密钥填充到16的倍数</span></span><br><span class="line">    key = key + (<span class="number">16</span> - <span class="built_in">len</span>(key) % <span class="number">16</span>) * <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">    <span class="comment"># 创建AES密码器对象</span></span><br><span class="line">    cipher = AES.new(key.encode(), AES.MODE_ECB)</span><br><span class="line">    <span class="comment"># 解码Base64编码的密文</span></span><br><span class="line">    ciphertext = base64.b64decode(ciphertext)</span><br><span class="line">    <span class="comment"># 解密</span></span><br><span class="line">    plaintext = cipher.decrypt(ciphertext)</span><br><span class="line">    <span class="comment"># 去除填充字符</span></span><br><span class="line">    plaintext = plaintext.rstrip(<span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> plaintext.decode()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>RSA是一种公钥加密算法，它可以用于保护数据的机密性和完整性。它基于两个大质数的乘积难以被分解的数学问题，通过这种问题的解决来保护数据的安全性。</p>
<p>RSA算法包括三个步骤：密钥生成、加密和解密。在密钥生成过程中，首先选择两个大质数p和q，计算它们的乘积n&#x3D;p<em>q，并选择一个整数e，使得e和(p-1)</em>(q-1)互质。然后计算d，使得(d<em>e) mod((p-1)</em>(q-1))&#x3D;1。公钥是(e,n)，私钥是(d,n)。</p>
<p>在加密过程中，要发送的消息m被转换为整数M，并用公钥(e,n)进行加密，计算C&#x3D;M^e mod n。</p>
<p>在解密过程中，使用私钥(d,n)对加密的消息进行解密，计算M&#x3D;C^d mod n。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_v1_5</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_key_pair</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成RSA密钥对&quot;&quot;&quot;</span></span><br><span class="line">    key_pair = RSA.generate(<span class="number">2048</span>)</span><br><span class="line">    private_key = key_pair.export_key()</span><br><span class="line">    public_key = key_pair.publickey().export_key()</span><br><span class="line">    <span class="keyword">return</span> private_key, public_key</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">public_key, plaintext</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;RSA加密&quot;&quot;&quot;</span></span><br><span class="line">    key = RSA.import_key(public_key)</span><br><span class="line">    cipher = PKCS1_v1_5.new(key)</span><br><span class="line">    ciphertext = cipher.encrypt(plaintext.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(ciphertext).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">private_key, ciphertext</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;RSA解密&quot;&quot;&quot;</span></span><br><span class="line">    key = RSA.import_key(private_key)</span><br><span class="line">    cipher = PKCS1_v1_5.new(key)</span><br><span class="line">    ciphertext = base64.b64decode(ciphertext.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    plaintext = cipher.decrypt(ciphertext, <span class="literal">None</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 生成RSA密钥对</span></span><br><span class="line">    private_key, public_key = generate_key_pair()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># unicode 转str</span></span><br><span class="line">    <span class="built_in">print</span>(private_key.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(public_key.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="comment"># 加密消息</span></span><br><span class="line">    message = <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">    ciphertext = encrypt(public_key, message)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;加密后的消息：&#x27;</span>, ciphertext)</span><br><span class="line">    <span class="comment"># 解密消息</span></span><br><span class="line">    plaintext = decrypt(private_key, ciphertext)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;解密后的消息：&#x27;</span>, plaintext)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="摘要算法，非对称加密算法与对称加密算法-安全性-比较"><a href="#摘要算法，非对称加密算法与对称加密算法-安全性-比较" class="headerlink" title="摘要算法，非对称加密算法与对称加密算法 安全性 比较"></a>摘要算法，非对称加密算法与对称加密算法 安全性 比较</h3><p><em>引用博客  <a href="https://blog.betamao.me/posts/2021/24/pkcs-v1_5_misuse/">https://blog.betamao.me/posts/2021/24/pkcs-v1_5_misuse/</a></em></p>
<ul>
<li><strong>摘要算法</strong>通过单向陷门函数将任意长度映射到固定长度，这个过程是不可逆的，再加上它的抗碰撞性让它成为标识数据的好方法，这方面如果用的算法是老古董就可能受碰撞和<a href="http://blog.chinaunix.net/uid-27070210-id-3255947.html">长度扩展攻击</a>的影响。</li>
<li><strong>对称加密算法</strong>使用的加解密钥相同，可再分为流密码与分组密码，流密码将它的密钥作为随机数种子通过伪随机生成函数源源不断地生成随机数，明文与之异或就得到了密文，由于异或运算的特性密文与之异或也就恢复了明文，因此它的加解密算法是一样的，而且它针对的任意长度的数据。分组密码的密钥和加密长度是固定的，它会对加密密钥进行一些变换，再与明文进行运算，该过程可能进行多次因此加解密算法不一定相同，由于它只能加密固定长度的数据，而一般要加密的数据长度都不满足要求，此时就需要把数据分组，若分组后最后一组的长度不满足要求又需要对其填充，前者就是分组密码的工作模式。是否需要填充也和工作模式相关，如OFB模式就可以将过程转换为类似流密码的方式，而XTS使用密文窃取也不需要填充，另外即使长度刚好符合也可能需要填充，如PKCS7此时就需要再填充一个完整的分组，之前提到若PKCS7与CBC模式组合时，就有可能出现<a href="http://blog-archive.betamao.me/2019/11/15/shiro-po721%E5%88%A9%E7%94%A8%E7%AE%80%E6%9E%90/#padding-oracle">PaddingOracle</a>漏洞，即若服务端会返回解密状态则可以通过推测加密任何数据。</li>
<li><strong>非对称加密算法</strong>加解密不再使用相同的密钥，而且它的结构和对称密码有很大的不同，对称密码更像是逻辑位运算而非对称是数学运算，它利用的全是数学上的难题，就是(给一个限制)后只有正向计算的算法，而还没有逆向计算的算法(大整数分解，椭圆曲线离散对数，格最短向量等)，先随机生成符合要求的私钥，私钥到公钥的生成过程是正向的有算法因此很容易，而反过来就没有算法可恢复，通过公开公钥就可实现加密与签名功能，由于这种加密也是在有限的范围上完成的因此单次运算的数字大小有限制，为此也需要对其分组填充，RSA就有PKCS1 V1.5与PKCS OAEP。</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>加密算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常用加密算法</title>
    <url>/2023/02/05/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="常用加密算法"><a href="#常用加密算法" class="headerlink" title="常用加密算法"></a>常用加密算法</h2><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><h4 id="Base64编码简介"><a href="#Base64编码简介" class="headerlink" title="Base64编码简介"></a>Base64编码简介</h4><p>Base64是一种编码方式,这个术语最初是在“MIME内容传输编码规范”中提出的。Base64不是一种加密算法，它实际上是一种“二进制转换到文本”的编码方式，它能够将任意二进制数据转换为ASCII字符串的形式，以便在只支持文本的环境中也能够顺利地传输二进制数据。</p>
<ul>
<li>base64编码：把二进制数据转换为字符</li>
<li>base64接码：把字符转为二进制数据</li>
</ul>
<p>这看起来可能有些奇怪，因为大多数的编码都是由字符转化成二进制的过程，而从二进制转成字符的过程称为解码。而Base64的概念就恰好反了，由二进制转到字符称为编码，由字符到二进制称为解码。</p>
<h4 id="Base64编码由来"><a href="#Base64编码由来" class="headerlink" title="Base64编码由来"></a>Base64编码由来</h4><p>因为有些网络传输渠道并不支持所有字节，例如传统的邮件只支持可见字符的传输，像<a href="id=#jump">ASCII</a>码的控制字符（<a href="id=#jump">ASCII</a>包含了 128 个字符。其中前 32 个， 0-31 ，即 0x00-0x1F ，都是不可见字符。这些字符，就叫做控制字符。）就不能通过邮件传输。另外，例如图片二进制流的每个字节不可能全部都是可见字符，所以就传送不了。</p>
<p>最好的方法就是在不改变传统协议的情况下，做一种扩展方案来支持二进制文件的传送，把不可能打印的字符用可打印的字符标识，问题就解决了。Base64编码就应运而生，Base64就是一种基于64个可打印字符来表示二进制数据的表示方法</p>
<h4 id="Base64编码原理"><a href="#Base64编码原理" class="headerlink" title="Base64编码原理"></a><strong>Base64编码原理</strong></h4><p>Base64编码索引表，字符选用了“A-Z 、 a-z 、 0-9、+、 &#x2F; ”64个可打印字符。数字代表字符索引，这个是标准Base64标准协议规定的，不能更改。64个字节用6个bit位就可以全部表示（32+16+8+4+2+1）就可以全部表示。这里注意一个Base64字符是8个bit，但有效部分只有右边6个bit，左边两个永远是0。</p>
<p>***PS:***Base64编码有效位为6bit,左边两个为0，也就是00xxxxxx形式，而一个字符表示8bit,所以Base64在编码时可能会遇到bit位不足得情况，这种情况下会在字符后补充&#x3D;</p>
<h5 id="JAVA代码-JDK8-实现："><a href="#JAVA代码-JDK8-实现：" class="headerlink" title="JAVA代码 JDK8 实现："></a>JAVA代码 JDK8 实现：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jdk</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;兔年顶呱呱&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] encode = Base64.getEncoder().encode(s.getBytes(UTF_8));</span><br><span class="line">    System.out.println(<span class="string">&quot;encode: &quot;</span>+ <span class="keyword">new</span> <span class="title class_">String</span>(encode,UTF_8)); <span class="comment">// 输出为:5YWU5bm06aG25ZGx5ZGx</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">asB64</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(<span class="string">&quot;some string&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">    System.out.println(asB64); <span class="comment">// 输出为: c29tZSBzdHJpbmc=</span></span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] decode = Base64.getDecoder().decode(encode);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(decode, UTF_8);</span><br><span class="line">    System.out.println(<span class="string">&quot;decode: &quot;</span>+ s1);<span class="comment">//decode: 兔年顶呱呱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><code>Base64.getEncoder().encodeToString</code></em>  等效于  <em>Base64.getEncoder().encode + new String(s,”UTF_8”)</em></p>
<h5 id="JAVA代码Apache工具包实现"><a href="#JAVA代码Apache工具包实现" class="headerlink" title="JAVA代码Apache工具包实现"></a>JAVA代码Apache工具包实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">base64</span><span class="params">()</span>&#123;</span><br><span class="line">     String s=<span class="string">&quot;2023兔年大吉&quot;</span>;</span><br><span class="line">     <span class="type">byte</span>[] bytes = Base64.encodeBase64(StringUtils.getBytesUtf8(s));</span><br><span class="line">     System.out.println(<span class="string">&quot;encode: &quot;</span> + StringUtils.newStringUtf8(bytes));</span><br><span class="line"></span><br><span class="line">     <span class="type">byte</span>[] bytes1 = Base64.decodeBase64(StringUtils.newStringUtf8(bytes));</span><br><span class="line">     System.out.println(<span class="string">&quot;decode:&quot;</span> +StringUtils.newStringUtf8(bytes1));</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h5 id="Python代码实现："><a href="#Python代码实现：" class="headerlink" title="Python代码实现："></a>Python代码实现：</h5><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;hello world&quot;</span>.encode()</span><br><span class="line">encode = base64.b64encode(s)</span><br><span class="line"><span class="built_in">print</span>(encode.decode())</span><br><span class="line">decode = base64.b64decode(encode)</span><br><span class="line"><span class="built_in">print</span>(decode.decode())</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">    aGVsbG8gd29ybGQ=</span></span><br><span class="line"><span class="string">    hello world</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="URLEncode"><a href="#URLEncode" class="headerlink" title="URLEncode"></a>URLEncode</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul>
<li>当字符串数据以<code>url</code>的形式传递给web服务器时,字符串中是不允许出现空格和特殊字符</li>
<li>因为 <code>url</code> 对字符有限制，比如把一个邮箱放入 <code>url</code>，就需要使用 <code>urlencode</code> 函数，因为 <code>url</code> 中不能包含 <code>@</code> 字符。</li>
<li><code>url</code>转义其实也只是为了符合<code>url</code>的规范而已。因为在标准的<code>url</code>规范中中文和很多的字符是不允许出现在<code>url</code>中</li>
</ul>
<h4 id="URLEncode原理"><a href="#URLEncode原理" class="headerlink" title="URLEncode原理"></a>URLEncode原理</h4><p>取出字符的ASCII码，转成16进制，然后前面加上百分号即可。如果是多字节的字符，则取出每一字节，按照同样的规则进行转换</p>
<p>如问号<code>?</code>的ASCII码为<code>63</code>，转换为16进制为<code>3F</code>，所以<code>%3F</code>即为<code>?</code>进行<code>Urlencode</code>编码的结果</p>
<h5 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">url</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;梦断香消四十年，沈园柳老不吹绵。&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> URLEncoder.encode(s, UTF_8);</span><br><span class="line">        System.out.println(<span class="string">&quot;encode: &quot;</span>+ encode);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">decode</span> <span class="operator">=</span> URLDecoder.decode(encode, UTF_8);</span><br><span class="line">        System.out.println(<span class="string">&quot;decode:&quot;</span> + decode);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">encode: %E6%A2%A6%E6%96%AD%E9%A6%99%E6%B6%88%E5%9B%9B%E5%8D%81%E5%B9%B4%EF%BC%8C%E6%B2%88%E5%9B%AD%E6%9F%B3%E8%80%81%E4%B8%8D%E5%90%B9%E7%BB%B5%E3%80%82</span></span><br><span class="line"><span class="comment">decode:梦断香消四十年，沈园柳老不吹绵。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  urllib.parse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parse = <span class="string">&quot;茨菰叶烂别西湾，莲子花开犹未还。&quot;</span></span><br><span class="line">poem = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;《江南行》&quot;</span>,</span><br><span class="line">    <span class="string">&quot;author&quot;</span>: <span class="string">&quot;张潮&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">encode_poem = urllib.parse.urlencode(poem) 			<span class="comment">#对字典进行编码</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;encode_poem: <span class="subst">&#123;encode_poem&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">decode_poem = urllib.parse.unquote(encode_poem) 	<span class="comment">#解码</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;decode: <span class="subst">&#123;decode_poem&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">encode = urllib.parse.quote(parse) 					<span class="comment">#对字符串进行编码</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;encode: &quot;</span> + encode)</span><br><span class="line"></span><br><span class="line">decode = urllib.parse.unquote(encode) 				<span class="comment">#解码</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;decode: <span class="subst">&#123;decode&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">encode_poem: name=%E3%80%8A%E6%B1%9F%E5%8D%97%E8%A1%8C%E3%80%8B&amp;author=%E5%BC%A0%E6%BD%AE</span></span><br><span class="line"><span class="string">decode: name=《江南行》&amp;author=张潮</span></span><br><span class="line"><span class="string">encode: %E8%8C%A8%E8%8F%B0%E5%8F%B6%E7%83%82%E5%88%AB%E8%A5%BF%E6%B9%BE%EF%BC%8C%E8%8E%B2%E5%AD%90%E8%8A%B1%E5%BC%80%E7%8A%B9%E6%9C%AA%E8%BF%98%E3%80%82</span></span><br><span class="line"><span class="string">decode: 茨菰叶烂别西湾，莲子花开犹未还。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><h4 id="MD5简介"><a href="#MD5简介" class="headerlink" title="MD5简介"></a>MD5简介</h4><p>MD5加密全程是Message-Digest <code>Algoorithm</code> 5（信息-摘要 算法），它对信息进行摘要采集，再通过一定的位运算，最终获取加密后的MD5字符串。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>针对不同长度待加密的数据、字符串等等，其都可以返回一个固定长度的MD5加密字符串。（通常32位的16进制字符串）；</li>
<li>其加密过程几乎不可逆，除非维护一个庞大的Key-Value数据库来进行碰撞破解，否则几乎无法解开。</li>
<li>运算简便，且可实现方式多样，通过一定的处理方式也可以避免碰撞算法的破解。</li>
<li>对于一个固定的字符串。数字等等，MD5加密后的字符串是固定的，也就是说不管MD5加密多少次，都是同样的结果。</li>
</ul>
<h4 id="md5原理"><a href="#md5原理" class="headerlink" title="md5原理"></a>md5原理</h4><p>1、对编码文本bit位数对512取模，要求%512&#x3D;448，不足位在原始位后先加1后补0，直到满足条件</p>
<p>512bit&#x2F;8 &#x3D; 64位,也就是最后返回得固定位数，余448是为了在后面（512-448&#x3D;）64bit放入原始长度</p>
<p>2、在这个结果后面附加一个以64位二进制表示的填充前信息长度（单位为Bit），如果二</p>
<p>进制表示的填充前信息长度超过64位，则取低64位。</p>
<p>3、经过这两步的处理，信息的位长&#x3D;N<em>512+448+64&#x3D;(N+1）</em>512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求。</p>
<p>4、MD5的实现需要每512个字节进行一次处理，后一次处理的输入为前一次处理的输出，因此，在循环处理开始之前，需要拿4个标准数作为输入，它们分别是：</p>
<p><code>A=0x67452301,B=0xefcdab89,C=0x98badcfe,D=0x10325476;</code></p>
<p>5、进行N轮循环处理，将最后的结果输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">通过上面的标准128bit 输入，参与每组512bit 计算，得到一个新的<span class="number">128</span>值，接着参与下一轮循环运算，最终得到一个<span class="number">128</span>位的值；</span><br><span class="line">具体运算：</span><br><span class="line">这里用到<span class="number">4</span> 个逻辑函数F,G,H,I，分别对应<span class="number">4</span> 轮运算，它们将参与运算。（<span class="number">4</span>轮<span class="number">16</span>步）</span><br><span class="line">第一轮逻辑函数：F(b,c,d)=(b&amp;c)|((~b)&amp;d) 参与第一轮的<span class="number">16</span> 步运算 (b,c,d均为<span class="number">32</span>位数)</span><br><span class="line">第二轮逻辑函数：G(b,c,d)=(b&amp;d)|(c&amp;(~d)) 参与第二轮的<span class="number">16</span> 步运算</span><br><span class="line">第三轮逻辑函数：H(b,c,d)= bcd 参与第三轮的<span class="number">16</span> 步运算</span><br><span class="line">第四轮逻辑函数：I(b,c,d)= c^(b|(~d)) 参与第四轮的<span class="number">16</span> 步运算</span><br><span class="line">再引入一个移位函数MOVE(X,n)，它将整型变量X 左循环移n 位，如变量X 为<span class="number">32</span> 位，则MOVE(X,n)= (X</span><br><span class="line">&lt;&lt; n) | (X &gt;&gt; (<span class="number">32</span> - n))。</span><br></pre></td></tr></table></figure>

<h4 id="JAVA代码实现"><a href="#JAVA代码实现" class="headerlink" title="JAVA代码实现"></a>JAVA代码实现</h4><p><code>Apache.commons</code><em>工具包</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMD5</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">poem</span> <span class="operator">=</span> <span class="string">&quot;宿空房，秋夜长，夜长无寐天不明。&quot;</span>;</span><br><span class="line">      <span class="comment">// 基于apache.commons框架中的DigestUtils工具类进行密码加密</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> DigestUtils.md5Hex(poem.getBytes());</span><br><span class="line"></span><br><span class="line">      System.out.println(encode);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><em>JDK</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>[] HEX_CHARS = <span class="string">&quot;0123456789abcdef&quot;</span>.toCharArray();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">poem</span> <span class="operator">=</span> <span class="string">&quot;习习谷风，维山崔嵬&quot;</span>;</span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md5</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] digest = md5.digest(poem.getBytes(UTF_8));</span><br><span class="line">        System.out.println(hexToStr(digest));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">hexToStr</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line"><span class="comment">//        897b01ff2de4733038564c342d59252d</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(bytes.length * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">fifteen</span> <span class="operator">=</span> <span class="number">0x0f</span>;<span class="comment">//十六进制中的 15</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;<span class="comment">//byte 为 32 位</span></span><br><span class="line">            str.append(HEX_CHARS[(b &gt;&gt; <span class="number">4</span>) &amp; fifteen]);<span class="comment">//高四位</span></span><br><span class="line">            str.append(HEX_CHARS[b &amp; fifteen]);<span class="comment">//低四位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="SHA256和SHA512"><a href="#SHA256和SHA512" class="headerlink" title="SHA256和SHA512"></a>SHA256和SHA512</h3><p>SHA-256信息摘要算法，也是一种<strong>密码散列函数</strong>对于任意长度的消息，SHA256都会产生一个256bit长的散列值（哈希值）用于确保信息传输完整一致，称作消息摘要。这个摘要相当于是个长度为32个字节的数组，通常用一个长度为64的十六进制字符串来表示</p>
<p>SHA-512同理</p>
<p>原理同md5相似</p>
<h4 id="SHA256代码实现"><a href="#SHA256代码实现" class="headerlink" title="SHA256代码实现"></a>SHA256代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hashUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>[] HEX_CHARS = <span class="string">&quot;0123456789abcdef&quot;</span>.toCharArray();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">hexToStr</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(bytes.length * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">fifteen</span> <span class="operator">=</span> <span class="number">0x0f</span>;<span class="comment">//十六进制中的 15</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;<span class="comment">//byte 为 32 位</span></span><br><span class="line">            str.append(HEX_CHARS[(b &gt;&gt; <span class="number">4</span>) &amp; fifteen]);<span class="comment">//高四位</span></span><br><span class="line">            str.append(HEX_CHARS[b &amp; fifteen]);<span class="comment">//低四位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    JDK原生</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sha256</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line"><span class="comment">//        92dd9f6a5b38c773b7b6ac894d9538917d75674d18336aba8eaaa3742ada6a46</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">poem</span> <span class="operator">=</span> <span class="string">&quot;当时轻别意中人，山长水远知何处&quot;</span>;</span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">encode</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-256&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] digest = encode.digest(poem.getBytes(UTF_8));</span><br><span class="line">        System.out.println(hashUtil.hexToStr(digest));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//apache工具包</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apasha256</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">poem</span> <span class="operator">=</span> <span class="string">&quot;当时轻别意中人，山长水远知何处&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> DigestUtils.sha256Hex(poem.getBytes(UTF_8));</span><br><span class="line">        System.out.println(encode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="SHA512-代码实现"><a href="#SHA512-代码实现" class="headerlink" title="SHA512 代码实现"></a>SHA512 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    JDK原生</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sha512</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">poem</span> <span class="operator">=</span> <span class="string">&quot;当时轻别意中人，山长水远知何处&quot;</span>;</span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">encode</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-512&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] digest = encode.digest(poem.getBytes(UTF_8));</span><br><span class="line">        System.out.println(hashUtil.hexToStr(digest));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    apache 工具包</span></span><br><span class="line"><span class="comment">//    c8da19b2c1b111952e338a73f71826ab6c759088c8e61093161d1112a632de75dc469a54ac6d98c0b84e460ed8911f5d5428d4aff812f39784b4763658efc292</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apasha512</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">poem</span> <span class="operator">=</span> <span class="string">&quot;当时轻别意中人，山长水远知何处&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> DigestUtils.sha512Hex(poem.getBytes(UTF_8));</span><br><span class="line">        System.out.println(encode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>md5</tag>
        <tag>sha256</tag>
      </tags>
  </entry>
  <entry>
    <title>线程的生命周期和常用方法</title>
    <url>/2023/05/19/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线程的生命周期和常用方法"><a href="#线程的生命周期和常用方法" class="headerlink" title="线程的生命周期和常用方法"></a>线程的生命周期和常用方法</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>根据<code>jdk</code>官方文档，线程状态有以下几种</p>
<ul>
<li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Thread.State.html#NEW"><code>NEW</code></a><br>尚未启动的线程处于此状态。</li>
<li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Thread.State.html#RUNNABLE"><code>RUNNABLE</code></a><br>在Java虚拟机中执行的线程处于此状态。</li>
<li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Thread.State.html#BLOCKED"><code>BLOCKED</code></a><br>被阻塞等待监视器锁定的线程处于此状态。</li>
<li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Thread.State.html#WAITING"><code>WAITING</code></a><br>正在等待另一个线程执行特定动作的线程处于此状态。</li>
<li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Thread.State.html#TIMED_WAITING"><code>TIMED_WAITING</code></a><br>正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。</li>
<li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Thread.State.html#TERMINATED"><code>TERMINATED</code></a><br>已退出的线程处于此状态。</li>
</ul>
<p>一个线程可以在给定时间点处于一个状态。 这些状态是不反映任何操作系统线程状态的虚拟机状态。</p>
<h3 id="如图示所见"><a href="#如图示所见" class="headerlink" title="如图示所见"></a>如图示所见</h3><p><img src="https://pic2.imgdb.cn/item/6466c5a70d2dde57773e2592.png"></p>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><h4 id="NEW-x2F-TIMED-WAITING-x2F-TERMINATED"><a href="#NEW-x2F-TIMED-WAITING-x2F-TERMINATED" class="headerlink" title="NEW &#x2F; TIMED_WAITING &#x2F; TERMINATED"></a>NEW &#x2F; TIMED_WAITING &#x2F; TERMINATED</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadState</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span>+ thread.getState());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程状态：&quot;</span> + thread.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">线程状态：NEW</span><br><span class="line">线程状态：TIMED_WAITING</span><br><span class="line">线程状态：TERMINATED</span><br><span class="line">线程状态：TERMINATED</span><br></pre></td></tr></table></figure>



<h4 id="WAITING-x2F-BLOCKED"><a href="#WAITING-x2F-BLOCKED" class="headerlink" title="WAITING &#x2F; BLOCKED"></a>WAITING &#x2F; BLOCKED</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockThreadState</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">BlockThreadState</span> <span class="variable">blockThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockThreadState</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(blockThread);</span><br><span class="line">        System.out.println(<span class="string">&quot;thread state : &quot;</span> + thread.getState());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;thread state : &quot;</span> + thread.getState());</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            lock.notify();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;thread state : &quot;</span> + thread.getState());</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;thread state : &quot;</span> + thread.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">				<span class="comment">// wait状态</span></span><br><span class="line">                lock.wait();</span><br><span class="line">                <span class="comment">// synchronized重新拿到锁 处于block状态</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread state : NEW</span><br><span class="line">thread state : WAITING</span><br><span class="line">thread state : BLOCKED</span><br><span class="line">thread state : TERMINATED</span><br></pre></td></tr></table></figure>



<h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><p>wait()方法执行后，会阻塞线程，同时释放锁，如果想要唤醒该线程，则需要以下条件</p>
<ul>
<li>另一个线程调用这个对象的notify()方法，且刚好被唤醒的时本线程</li>
<li>另一个线程调用了这个对象的<code>notifyAll</code>()方法</li>
<li>过了wait(long timeout) 规定的超时时间，如果传入0就是永久等待</li>
<li>线程自身调用了interrupt() </li>
<li></li>
</ul>
<p><em><strong>PS： 使用wait()方法时，必须先拥有monitor锁, 也就是说wait方法需要放在同步代码块中执行</strong></em></p>
<h3 id="notify-x2F-notifyAll"><a href="#notify-x2F-notifyAll" class="headerlink" title="notify&#x2F;notifyAll"></a>notify&#x2F;<code>notifyAll</code></h3><p>notify&#x2F;<code>notifyAll</code>用于唤醒线程，当另一个线程调用wait()进入  <code>waitting</code>状态时，另一个线程调用<code>notifyAll</code>()可唤醒当前线程（如果有多个线程，使用notify并不一定能够唤醒线程）</p>
<p>组合使用示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个等待线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">waitThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">WaitThread</span>(message));</span><br><span class="line">        <span class="comment">// 创建一个唤醒线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">notifyThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">NotifyThread</span>(message));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动等待线程和唤醒线程</span></span><br><span class="line">        waitThread.start();</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享的消息类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isReady</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">waitForMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!isReady) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 当消息不可用时，线程进入等待状态</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程进入等待状态&quot;</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行到这里表示收到消息，进行处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 做一些准备工作，例如获取消息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">        isReady = <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;唤醒等待的线程&quot;</span>);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaitThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Message message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WaitThread</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 等待消息</span></span><br><span class="line">        message.waitForMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotifyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Message message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotifyThread</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        message.sendMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">线程进入等待状态</span></span><br><span class="line"><span class="comment">唤醒等待的线程</span></span><br><span class="line"><span class="comment">收到消息！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Process finished with exit code 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="图示-monitor锁"><a href="#图示-monitor锁" class="headerlink" title="图示 monitor锁"></a>图示 monitor锁</h3><p><img src="https://pic2.imgdb.cn/item/6462384a0d2dde577761578b.png"></p>
<ul>
<li>Entry Set 入口集  <ul>
<li>线程进入后抢锁</li>
</ul>
</li>
<li>The owner 锁持有线程<ul>
<li>如果方法没有执行完之前没有释放锁，则程序正常退出并释放锁</li>
<li>如果方法没有执行完之前释放了锁如调用了wait()方法，则程序再次进入等待集进行抢锁</li>
</ul>
</li>
<li>Wait Set 等待集 <ul>
<li>如果上方入口集，不同点是等待集在执行方法锁时中途释放了锁</li>
</ul>
</li>
</ul>
<h3 id="wait、notify-实现生产者消费者模式"><a href="#wait、notify-实现生产者消费者模式" class="headerlink" title="wait、notify 实现生产者消费者模式"></a>wait、notify 实现生产者消费者模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductAndConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; container = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProductAndConsumer</span> <span class="variable">productAndConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductAndConsumer</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Product</span>(productAndConsumer));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(productAndConsumer));</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addObject</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (container.size() &gt;=<span class="number">100</span>)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        container.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;正在生产第&quot;</span>+ container.size() + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">conObject</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (container.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        container.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在消费第&quot;</span>+ container.size() + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProductAndConsumer productAndConsumer;</span><br><span class="line"></span><br><span class="line">    Product(ProductAndConsumer productAndConsumer)&#123;</span><br><span class="line">        <span class="built_in">this</span>.productAndConsumer = productAndConsumer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               productAndConsumer.addObject();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProductAndConsumer productAndConsumer;</span><br><span class="line"></span><br><span class="line">    Consumer(ProductAndConsumer productAndConsumer)&#123;</span><br><span class="line">        <span class="built_in">this</span>.productAndConsumer = productAndConsumer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               productAndConsumer.conObject();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul>
<li><strong>使用类<code>ProductAndConsumer</code>作为锁对象，container作为容器</strong></li>
<li><strong>wait notify来进行线程之间的通讯，在数量满足条件时使用wait释放当前锁对象，另一个对象拿到锁之后进行生产或消费</strong></li>
</ul>
<h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><p><img src="https://pic2.imgdb.cn/item/6466d6fd0d2dde577751102f.png"></p>
<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><p><code>Thread.sleep()</code>是Java中一个静态native方法，用于使当前线程进入休眠状态（暂停执行）一段指定的时间。</p>
<p>它的方法签名为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<p>参数<code>millis</code>表示线程休眠的时间，以毫秒为单位。传入的值是一个正整数，表示线程要休眠的毫秒数。注意，该方法会抛出<code>InterruptedException</code>异常，因为线程在休眠期间可能被其他线程中断。</p>
<h4 id="特点和用法"><a href="#特点和用法" class="headerlink" title="特点和用法"></a>特点和用法</h4><ul>
<li><strong>线程阻塞</strong>：调用<code>Thread.sleep()</code>方法会导致当前线程暂停执行，进入阻塞状态。在指定的时间内，线程不会进行任何操作。</li>
<li><strong>时间精度</strong>：传入的休眠时间是以毫秒为单位，但实际的休眠时间可能会稍长或稍短。具体的精度取决于底层操作系统和JVM的实现。</li>
<li><strong>中断响应</strong>：如果在线程休眠期间，另一个线程中断了正在休眠的线程，<code>Thread.sleep()</code>方法会抛出<code>InterruptedException</code>异常。可以在<code>catch</code>块中处理该异常，或者将异常继续向上抛出。</li>
<li><strong>不会释放锁</strong>：<code>Thread.sleep()</code>方法会暂停当前线程的执行，但不会释放任何锁。如果线程在执行同步代码块或同步方法时调用了<code>Thread.sleep()</code>，其他线程仍无法获得该锁。</li>
<li><strong>静态方法</strong>：<code>Thread.sleep()</code>是一个静态方法，可以直接通过<code>Thread</code>类调用，无需创建线程对象。</li>
<li><strong>用途</strong>：常见的用途包括模拟延迟、定时任务、控制线程执行顺序等。</li>
</ul>
<h4 id="Thread-sleep和TimeUnit比较"><a href="#Thread-sleep和TimeUnit比较" class="headerlink" title="Thread.sleep和TimeUnit比较"></a><code>Thread.sleep</code>和<code>TimeUnit</code>比较</h4><ul>
<li><strong>精度和可读性：</strong> <code>Thread.sleep()</code>的参数是以毫秒为单位的时间值，表示线程要休眠的时间。而<code>TimeUnit</code>提供了更高层次的时间单位，如<code>TimeUnit.SECONDS</code>表示秒，<code>TimeUnit.MILLISECONDS</code>表示毫秒等。使用<code>TimeUnit</code>可以使代码更具可读性，而不需要手动计算毫秒数。</li>
<li><strong>异常处理：</strong> <code>Thread.sleep()</code>方法会抛出<code>InterruptedException</code>异常，因为线程在休眠期间可能会被其他线程中断。而<code>TimeUnit</code>方式不会直接抛出异常，需要开发者手动处理中断情况。</li>
<li><strong>静态与非静态：</strong> <code>Thread.sleep()</code>是<code>Thread</code>类的静态方法，可以直接通过类名调用。而<code>TimeUnit</code>是一个枚举类，需要通过具体的枚举常量来调用其方法，例如<code>TimeUnit.SECONDS.sleep(1)</code>。</li>
<li><strong>可读性和易用性：</strong> 使用<code>TimeUnit</code>可以提高代码的可读性，因为可以直观地表示时间单位。此外，<code>TimeUnit</code>还提供了其他方法，如<code>TimeUnit.toMillis()</code>、<code>TimeUnit.toSeconds()</code>等，方便进行时间单位之间的转换。</li>
</ul>
<h5 id="TimeUnit源码"><a href="#TimeUnit源码" class="headerlink" title="TimeUnit源码"></a><code>TimeUnit</code>源码</h5><p><em>以下是截取部分源码</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TimeUnit</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs a &#123;<span class="doctag">@link</span> Thread#sleep(long, int) Thread.sleep&#125; using</span></span><br><span class="line"><span class="comment">     * this time unit.</span></span><br><span class="line"><span class="comment">     * This is a convenience method that converts time arguments into the</span></span><br><span class="line"><span class="comment">     * form required by the &#123;<span class="doctag">@code</span> Thread.sleep&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the minimum time to sleep. If less than</span></span><br><span class="line"><span class="comment">     * or equal to zero, do not sleep at all.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while sleeping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ms</span> <span class="operator">=</span> toMillis(timeout);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ns</span> <span class="operator">=</span> excessNanos(timeout, ms);</span><br><span class="line">            Thread.sleep(ms, ns);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>TimeUnit</code>底层还是调用了<code>Thread.sleep()</code> 有一个比较隐含的地方就是当使用过<code>TimeUnit</code>的<code>sleep</code>方法时，如果传入的时间小于是不会进入if判断，而<code>Thread.sleep()</code>方法如果传参小于0则会抛出异常(源码见下)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                            <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">        millis++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(millis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p><code>Thread.join()</code>是Java中的一个方法，用于等待调用该方法的线程执行完毕。它的作用是让当前线程等待指定线程执行结束，然后再继续执行当前线程的后续代码。</p>
<p>简单来说就是阻塞主线程。</p>
<h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行完毕&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;子线程&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">子线程执行完毕</span><br><span class="line">主线程执行完毕</span><br></pre></td></tr></table></figure>

<p>可以看到子线程等待了3秒，但是最终还是子线程先执行完毕在执行主线程打印，原因是因为thread1.join 对主线程进行了阻塞，这是主线程需要等子线程执行完毕才会执行后面的语句</p>
<h4 id="特点和注意事项"><a href="#特点和注意事项" class="headerlink" title="特点和注意事项"></a>特点和注意事项</h4><ul>
<li><strong>等待执行：</strong> 调用<code>join()</code>方法的线程将会等待指定线程执行完毕。如果指定线程已经执行完毕，则<code>join()</code>方法会立即返回。</li>
<li><strong>阻塞调用线程：</strong> 在调用<code>join()</code>方法期间，当前线程将会被阻塞，暂停执行。只有当指定线程执行完毕后，当前线程才会解除阻塞，继续执行。</li>
<li><strong>异常处理：</strong> <code>join()</code>方法会抛出<code>InterruptedException</code>异常，因为在等待过程中，当前线程可能会被中断。可以在<code>catch</code>块中处理该异常，或将异常继续向上抛出。</li>
<li><strong>顺序执行：</strong> 通过使用<code>join()</code>方法，可以控制线程的执行顺序。调用<code>join()</code>方法后，当前线程会等待指定线程执行完毕，然后再继续执行后续代码。</li>
<li><strong>调用对象：</strong> <code>join()</code>方法是一个实例方法，需要通过线程对象调用。例如，如果<code>thread1</code>是一个<code>Thread</code>对象，可以使用<code>thread1.join()</code>来等待<code>thread1</code>执行完毕。</li>
</ul>
<h4 id="源码和底层实现"><a href="#源码和底层实现" class="headerlink" title="源码和底层实现"></a>源码和底层实现</h4><p>以下截取部分<code>Thread.join</code>源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用的join(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际调用的本地native方法  wait</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到join的底层还是使用wait方法实现的，子线程调用wait方法让主线程进入等待状态，在运行结束后自动调用notify方法唤醒主线程。（具体唤醒的方法在jvm中）</p>
<p><em><strong>有一点疑问我没有找到解释：为什么调用子线程的wait(0)方法，阻塞的确是主线程呢？</strong></em></p>
<h4 id="CountDownLatch和CyclicBarrier"><a href="#CountDownLatch和CyclicBarrier" class="headerlink" title="CountDownLatch和CyclicBarrier"></a><code>CountDownLatch</code>和<code>CyclicBarrier</code></h4><p>使用<code>countDownLatch</code>和<code>CyclicBarrier</code>也可以实现线程之间的阻塞，具体暂不讨论</p>
<h3 id="yeild-让步"><a href="#yeild-让步" class="headerlink" title="yeild() (让步)"></a>yeild() (让步)</h3><p><code>yield()</code> 是一个静态方法，它属于 <code>Thread</code> 类，用于提示调度器将当前线程让出 CPU 的执行权，使得其他具有相同优先级的线程有机会执行。</p>
<p><code>yield()</code> 方法的调用并不能保证一定会使其他线程获得执行机会，它仅是一个提示。具体的调度行为取决于操作系统和 JVM 的实现。因此，在实际应用中，不应过度依赖 <code>yield()</code> 方法来控制线程的执行顺序，而应使用更可靠的线程同步机制来实现需要的线程协作和同步。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
